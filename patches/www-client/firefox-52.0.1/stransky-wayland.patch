diff --git a/browser/installer/package-manifest.in b/browser/installer/package-manifest.in
index a57879d..b6478f6 100644
--- a/browser/installer/package-manifest.in
+++ b/browser/installer/package-manifest.in
@@ -107,6 +107,9 @@
 #ifdef MOZ_GTK3
 @BINPATH@/@DLL_PREFIX@mozgtk@DLL_SUFFIX@
 @BINPATH@/gtk2/@DLL_PREFIX@mozgtk@DLL_SUFFIX@
+#ifdef MOZ_WAYLAND
+@BINPATH@/@DLL_PREFIX@mozwayland@DLL_SUFFIX@
+#endif
 #endif
 
 [browser]
diff --git a/config/system-headers b/config/system-headers
index e6374bd..73a2045 100644
--- a/config/system-headers
+++ b/config/system-headers
@@ -489,6 +489,7 @@ gdk/gdkkeysyms.h
 gdk/gdkprivate.h
 gdk/gdkx.h
 gdk/gdkdirectfb.h
+gdk/gdkwayland.h
 gdk-pixbuf/gdk-pixbuf.h
 Gestalt.h
 getopt.h
diff --git a/dom/ipc/ContentChild.cpp b/dom/ipc/ContentChild.cpp
index 8a26550..22ff711 100644
--- a/dom/ipc/ContentChild.cpp
+++ b/dom/ipc/ContentChild.cpp
@@ -524,6 +524,44 @@ NS_INTERFACE_MAP_BEGIN(ContentChild)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContentChild)
 NS_INTERFACE_MAP_END
 
+#ifdef MOZ_WIDGET_GTK
+// We need to keep in sync whith the same detection routine at nsAppRunner.cpp
+static char* detectDisplay(void)
+{
+  bool tryX11 = false;
+  bool tryWayland = false;
+  bool tryBroadway = false;
+
+  // Honor user backend selection
+  char *backend = PR_GetEnv("GDK_BACKEND");
+  if (!backend || strstr(backend, "*")) {
+    // Try all backends
+    tryX11 = true;
+    tryWayland = true;
+    tryBroadway = true;
+  } else if (backend) {
+    if (strstr(backend, "x11"))
+      tryX11 = true;
+    if (strstr(backend, "wayland"))
+      tryWayland = true;
+    if (strstr(backend, "broadway"))
+      tryBroadway = true;
+  }
+
+  char *display_name;
+  if (tryX11 && (display_name = PR_GetEnv("DISPLAY"))) {
+    return display_name;
+  } else if (tryWayland && (display_name = PR_GetEnv("WAYLAND_DISPLAY"))) {
+    return display_name;
+  } else if (tryBroadway && (display_name = PR_GetEnv("BROADWAY_DISPLAY"))) {
+    return display_name;
+  }
+
+  MOZ_ASSERT(display_name);
+  return nullptr;
+}
+#endif
+
 bool
 ContentChild::Init(MessageLoop* aIOLoop,
                    base::ProcessId aParentPid,
@@ -535,7 +573,7 @@ ContentChild::Init(MessageLoop* aIOLoop,
   // to use, and when starting under XWayland, it may choose to start with
   // the wayland backend instead of the x11 backend.
   // The DISPLAY environment variable is normally set by the parent process.
-  char* display_name = PR_GetEnv("DISPLAY");
+  char* display_name = detectDisplay();
   if (display_name) {
     int argc = 3;
     char option_name[] = "--display";
diff --git a/gfx/gl/GLContextProviderGLX.cpp b/gfx/gl/GLContextProviderGLX.cpp
index 9a1157f..09eb82a 100644
--- a/gfx/gl/GLContextProviderGLX.cpp
+++ b/gfx/gl/GLContextProviderGLX.cpp
@@ -67,6 +67,8 @@ HasExtension(const char* aExtensions, const char* aRequiredExtension)
 bool
 GLXLibrary::EnsureInitialized()
 {
+    return false;
+
     if (mInitialized) {
         return true;
     }
diff --git a/gfx/thebes/gfxFcPlatformFontList.cpp b/gfx/thebes/gfxFcPlatformFontList.cpp
index 4b82e80..b6e9167 100644
--- a/gfx/thebes/gfxFcPlatformFontList.cpp
+++ b/gfx/thebes/gfxFcPlatformFontList.cpp
@@ -772,12 +772,14 @@ PreparePattern(FcPattern* aPattern, bool aIsPrinterFont)
 #endif
 
 #ifdef MOZ_X11
-        FcValue value;
-        int lcdfilter;
-        if (FcPatternGet(aPattern, FC_LCD_FILTER, 0, &value)
-                == FcResultNoMatch &&
-            GetXftInt(DefaultXDisplay(), "lcdfilter", &lcdfilter)) {
-            FcPatternAddInteger(aPattern, FC_LCD_FILTER, lcdfilter);
+        if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
+            FcValue value;
+            int lcdfilter;
+            if (FcPatternGet(aPattern, FC_LCD_FILTER, 0, &value)
+                    == FcResultNoMatch &&
+                GetXftInt(DefaultXDisplay(), "lcdfilter", &lcdfilter)) {
+                FcPatternAddInteger(aPattern, FC_LCD_FILTER, lcdfilter);
+            }
         }
 #endif
     }
diff --git a/gfx/thebes/gfxPlatformGtk.cpp b/gfx/thebes/gfxPlatformGtk.cpp
index 9d7f512..5a5f7e3 100644
--- a/gfx/thebes/gfxPlatformGtk.cpp
+++ b/gfx/thebes/gfxPlatformGtk.cpp
@@ -105,14 +105,23 @@ gfxPlatformGtk::gfxPlatformGtk()
     InitBackendPrefs(canvasMask, BackendType::CAIRO,
                      contentMask, BackendType::CAIRO);
 
-#ifdef MOZ_X11
-    if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
-      mCompositorDisplay = XOpenDisplay(nullptr);
-      MOZ_ASSERT(mCompositorDisplay, "Failed to create compositor display!");
-    } else {
-      mCompositorDisplay = nullptr;
+#if defined(MOZ_X11)
+    mXCompositorDisplay = nullptr;
+    mWaylandCompositorDisplay = nullptr;
+
+    GdkDisplay *gdkDisplay = gdk_display_get_default();
+    mIsX11Display = GDK_IS_X11_DISPLAY(gdkDisplay);
+    if (mIsX11Display) {
+      mXCompositorDisplay = XOpenDisplay(nullptr);
+      MOZ_ASSERT(mXCompositorDisplay, "Failed to create compositor display!");
     }
-#endif // MOZ_X11
+#if defined(GDK_WINDOWING_WAYLAND)
+    else {
+      mWaylandCompositorDisplay = wl_display_connect(nullptr);
+      MOZ_ASSERT(mWaylandCompositorDisplay, "Failed to create compositor display!");
+    }
+#endif
+#endif // defined(MOZ_X11)
 }
 
 gfxPlatformGtk::~gfxPlatformGtk()
@@ -123,11 +132,16 @@ gfxPlatformGtk::~gfxPlatformGtk()
         gfxPangoFontGroup::Shutdown();
     }
 
-#ifdef MOZ_X11
-    if (mCompositorDisplay) {
-      XCloseDisplay(mCompositorDisplay);
+#if defined(MOZ_X11)
+    if (mIsX11Display) {
+       XCloseDisplay(mXCompositorDisplay);
+    }
+#if defined(GDK_WINDOWING_WAYLAND)
+    else {
+       wl_display_disconnect(mWaylandCompositorDisplay);
     }
-#endif // MOZ_X11
+#endif
+#endif
 }
 
 void
diff --git a/mozglue/misc/TimeStamp.h b/mozglue/misc/TimeStamp.h
index a1a0eb3..2440bdc 100644
--- a/mozglue/misc/TimeStamp.h
+++ b/mozglue/misc/TimeStamp.h
@@ -405,9 +405,11 @@ public:
    * on platforms that support vsync aligned refresh drivers / compositors
    * Verified true as of Jan 31, 2015: B2G and OS X
    * False on Windows 7
+   * Wayland/GTK event time also uses CLOCK_MONOTONIC.
    * UNTESTED ON OTHER PLATFORMS
    */
-#if defined(MOZ_WIDGET_GONK) || defined(XP_DARWIN)
+#if defined(MOZ_WIDGET_GONK) || defined(XP_DARWIN) || \
+    defined(MOZ_WIDGET_ANDROID) || defined(MOZ_WIDGET_GTK)
   static TimeStamp FromSystemTime(int64_t aSystemTime)
   {
     static_assert(sizeof(aSystemTime) == sizeof(TimeStampValue),
diff --git a/toolkit/components/remote/moz.build b/toolkit/components/remote/moz.build
index faa119e..50b13b7 100644
--- a/toolkit/components/remote/moz.build
+++ b/toolkit/components/remote/moz.build
@@ -13,7 +13,6 @@ XPIDL_MODULE = 'toolkitremote'
 SOURCES += [
     'nsXRemoteService.cpp',
 ]
-
 if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
     SOURCES += [
         'nsGTKRemoteService.cpp',
diff --git a/toolkit/components/remote/nsGTKRemoteService.cpp b/toolkit/components/remote/nsGTKRemoteService.cpp
index 860efe0..d72cf93 100644
--- a/toolkit/components/remote/nsGTKRemoteService.cpp
+++ b/toolkit/components/remote/nsGTKRemoteService.cpp
@@ -20,11 +20,17 @@
 #include "nsIWidget.h"
 #include "nsIAppShellService.h"
 #include "nsAppShellCID.h"
+#include "nsPrintfCString.h"
 
 #include "nsCOMPtr.h"
 
 #include "nsGTKToolkit.h"
 
+#ifdef ENABLE_REMOTE_DBUS
+#include <dbus/dbus.h>
+#include <dbus/dbus-glib-lowlevel.h>
+#endif
+
 NS_IMPL_ISUPPORTS(nsGTKRemoteService,
                   nsIRemoteService,
                   nsIObserver)
@@ -37,14 +43,24 @@ nsGTKRemoteService::Startup(const char* aAppName, const char* aProfileName)
 
   if (mServerWindow) return NS_ERROR_ALREADY_INITIALIZED;
 
-  XRemoteBaseStartup(aAppName, aProfileName);
-
   mServerWindow = gtk_invisible_new();
   gtk_widget_realize(mServerWindow);
-  HandleCommandsFor(mServerWindow, nullptr);
 
-  for (auto iter = mWindows.Iter(); !iter.Done(); iter.Next()) {
-    HandleCommandsFor(iter.Key(), iter.UserData());
+  mIsX11Display = GDK_IS_X11_DISPLAY(gdk_display_get_default());
+#ifdef ENABLE_REMOTE_DBUS
+  if (!mIsX11Display) {
+    if (!Connect(aAppName, aProfileName))
+      return NS_ERROR_FAILURE;
+  } else
+#endif
+  {
+    XRemoteBaseStartup(aAppName, aProfileName);
+
+    HandleCommandsFor(mServerWindow, nullptr);
+
+    for (auto iter = mWindows.Iter(); !iter.Done(); iter.Next()) {
+      HandleCommandsFor(iter.Key(), iter.UserData());
+    }
   }
 
   return NS_OK;
@@ -78,7 +94,7 @@ nsGTKRemoteService::RegisterWindow(mozIDOMWindow* aWindow)
   mWindows.Put(widget, weak);
 
   // If Startup() has already been called, immediately register this window.
-  if (mServerWindow) {
+  if (mServerWindow && mIsX11Display) {
     HandleCommandsFor(widget, weak);
   }
 
@@ -154,6 +170,161 @@ nsGTKRemoteService::HandlePropertyChange(GtkWidget *aWidget,
   return FALSE;
 }
 
+#ifdef ENABLE_REMOTE_DBUS
+
+void nsGTKRemoteService::OpenURL(const char *aCommandLine)
+{
+  
+  
+}
+
+#define MOZILLA_REMOTE_OBJECT       "/org/mozilla/Firefox/Remote"
+
+const char* introspect_xml =
+"<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\"\n"
+"\"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\";>\n"
+"<node>\n"
+" <interface name=\"org.freedesktop.DBus.Introspectable\">\n"
+"   <method name=\"Introspect\">\n"
+"     <arg name=\"data\" direction=\"out\" type=\"s\"/>\n"
+"   </method>\n"
+" </interface>\n"
+" <interface name=\"org.mozilla.firefox\">\n"
+"   <method name=\"OpenURL\">\n"
+"     <arg name=\"url\" direction=\"in\" type=\"s\"/>\n"
+"   </method>\n"
+" </interface>\n"
+"</node>\n";
+
+DBusHandlerResult
+nsGTKRemoteService::Introspect(DBusMessage *msg)
+{
+  DBusMessage *reply;
+
+  reply = dbus_message_new_method_return(msg);
+  if (!reply)
+    return DBUS_HANDLER_RESULT_NEED_MEMORY;
+
+  dbus_message_append_args(reply,
+      DBUS_TYPE_STRING, &introspect_xml,
+      DBUS_TYPE_INVALID);
+
+  dbus_connection_send(mConnection, reply, NULL);
+  dbus_message_unref(reply);
+
+  return DBUS_HANDLER_RESULT_HANDLED;
+}
+
+DBusHandlerResult
+nsGTKRemoteService::OpenURL(DBusMessage *msg)
+{
+  DBusMessage *reply = nullptr;
+  const char  *commandLine;
+
+  if (!dbus_message_get_args(msg, nullptr, DBUS_TYPE_STRING, &commandLine,
+                             DBUS_TYPE_INVALID)) {
+    reply = dbus_message_new_error(msg, "org.mozilla.firefox.Error",
+                                   "Wrong argument");
+  } else {
+    OpenURL(commandLine);
+    reply = dbus_message_new_method_return(msg);
+  }
+  
+  dbus_connection_send(mConnection, reply, NULL);
+  dbus_message_unref(reply);
+
+  return DBUS_HANDLER_RESULT_HANDLED;  
+}
+
+DBusHandlerResult
+nsGTKRemoteService::HandleDBusMessage(DBusConnection *aConnection, DBusMessage *msg)
+{
+  NS_ASSERTION(mConnection == aConnection, "Wrong D-Bus connection.");
+  
+  const char *method = dbus_message_get_member(msg);
+  const char *iface = dbus_message_get_interface(msg);
+
+  if ((strcmp("Introspect", method) == 0) &&
+     (strcmp("org.freedesktop.DBus.Introspectable", iface) == 0)) {
+    return Introspect(msg);
+  }
+
+  if ((strcmp("OpenURL", method) == 0) && 
+    (strcmp("org.mozilla.firefox", iface) == 0)) {
+    return OpenURL(msg);
+  }
+
+  return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+}
+
+void
+nsGTKRemoteService::UnregisterDBusInterface(DBusConnection *aConnection)
+{
+  NS_ASSERTION(mConnection == aConnection, "Wrong D-Bus connection.");
+  // Not implemented
+}
+
+static DBusHandlerResult
+message_handler(DBusConnection *conn, DBusMessage *msg, void *user_data)
+{
+  auto interface = static_cast<nsGTKRemoteService*>(user_data);
+  return interface->HandleDBusMessage(conn, msg);
+}
+
+static void
+unregister(DBusConnection *conn, void *user_data)
+{
+  auto interface = static_cast<nsGTKRemoteService*>(user_data);
+  interface->UnregisterDBusInterface(conn);
+}
+
+static DBusObjectPathVTable remoteHandlersTable = {
+  .unregister_function  = unregister,
+  .message_function = message_handler,
+};
+
+bool
+nsGTKRemoteService::Connect(const char* aAppName, const char* aProfileName)
+{
+  mConnection = already_AddRefed<DBusConnection>(
+    dbus_bus_get(DBUS_BUS_SESSION, nullptr));
+  if (!mConnection)
+    return false;
+
+  dbus_connection_set_exit_on_disconnect(mConnection, false);
+
+  nsAutoCString interfaceName;
+  interfaceName = nsPrintfCString("org.mozilla.%s.%s", aAppName, aProfileName);
+
+  int ret = dbus_bus_request_name(mConnection, interfaceName.get(),
+                                  DBUS_NAME_FLAG_DO_NOT_QUEUE, nullptr);
+  // The interface is already owned - there is another application/profile
+  // instance already running.
+  if (ret == -1) {
+    dbus_connection_unref(mConnection);
+    mConnection = nullptr;
+    return false;
+  }
+
+  if (!dbus_connection_register_object_path(mConnection, MOZILLA_REMOTE_OBJECT,
+                                            &remoteHandlersTable, this)) {
+    dbus_connection_unref(mConnection);
+    mConnection = nullptr;
+    return false;
+  }
+
+  return true;
+}
+
+void
+nsGTKRemoteService::Disconnect()
+{
+  if (mConnection) {
+    dbus_connection_unref(mConnection);
+    mConnection = nullptr;
+  }
+}
+#endif
 
 // {C0773E90-5799-4eff-AD03-3EBCD85624AC}
 #define NS_REMOTESERVICE_CID \
diff --git a/toolkit/components/remote/nsGTKRemoteService.h b/toolkit/components/remote/nsGTKRemoteService.h
index 034a77a..638558b 100644
--- a/toolkit/components/remote/nsGTKRemoteService.h
+++ b/toolkit/components/remote/nsGTKRemoteService.h
@@ -8,6 +8,10 @@
 #ifndef __nsGTKRemoteService_h__
 #define __nsGTKRemoteService_h__
 
+#if defined(MOZ_WAYLAND) && defined(MOZ_ENABLE_DBUS)
+#define ENABLE_REMOTE_DBUS 1
+#endif
+
 #include <gdk/gdk.h>
 #include <gdk/gdkx.h>
 #include <gtk/gtk.h>
@@ -15,6 +19,10 @@
 #include "nsInterfaceHashtable.h"
 #include "nsXRemoteService.h"
 #include "mozilla/Attributes.h"
+#ifdef ENABLE_REMOTE_DBUS
+#include "mozilla/ipc/DBusConnectionRefPtr.h"
+#endif
+
 
 class nsGTKRemoteService final : public nsXRemoteService
 {
@@ -24,8 +32,15 @@ public:
   NS_DECL_NSIREMOTESERVICE
 
 
-  nsGTKRemoteService() :
-    mServerWindow(nullptr) { }
+  nsGTKRemoteService() 
+    : mServerWindow(nullptr)
+#ifdef ENABLE_REMOTE_DBUS
+    , mConnection(nullptr)
+#endif    
+    { }
+
+    DBusHandlerResult HandleDBusMessage(DBusConnection *aConnection, DBusMessage *msg);
+    void UnregisterDBusInterface();
 
 private:
   ~nsGTKRemoteService() { }
@@ -42,8 +57,22 @@ private:
   virtual void SetDesktopStartupIDOrTimestamp(const nsACString& aDesktopStartupID,
                                               uint32_t aTimestamp) override;
 
+#ifdef ENABLE_REMOTE_DBUS
+  void OpenURL(const char *aCommandLine);
+
+  DBusHandlerResult OpenURL(DBusMessage *msg);
+  DBusHandlerResult Introspect(DBusMessage *msg);
+
+  bool Connect(const char* aAppName, const char* aProfileName);
+  void Disconnect();
+#endif
+
   nsInterfaceHashtable<nsPtrHashKey<GtkWidget>, nsIWeakReference> mWindows;
-  GtkWidget* mServerWindow;  
+  GtkWidget* mServerWindow;
+  bool       mIsX11Display;
+#ifdef ENABLE_REMOTE_DBUS
+  RefPtr<DBusConnection> mConnection;
+#endif
 };
 
 #endif // __nsGTKRemoteService_h__
diff --git a/toolkit/library/moz.build b/toolkit/library/moz.build
index 8adfc80..3006fd0 100644
--- a/toolkit/library/moz.build
+++ b/toolkit/library/moz.build
@@ -135,6 +135,11 @@ if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gtk3':
         'mozgtk_stub',
     ]
 
+if CONFIG['MOZ_WAYLAND']:
+    USE_LIBS += [
+        'mozwayland',
+    ]
+
 if CONFIG['MOZ_JPROF']:
     USE_LIBS += [
         'jprof',
diff --git a/toolkit/moz.configure b/toolkit/moz.configure
index 68f9814..a90e365 100644
--- a/toolkit/moz.configure
+++ b/toolkit/moz.configure
@@ -145,11 +145,16 @@ def toolkit(value, target):
 
     return platform_choices[0]
 
+@depends(toolkit)
+def wayland(toolkit):
+    return toolkit == 'cairo-gtk3-wayland'
 
 @depends(toolkit)
 def toolkit(toolkit):
     if toolkit == 'cairo-gtk2-x11':
         widget_toolkit = 'gtk2'
+    elif toolkit == 'cairo-gtk3-wayland' :
+        widget_toolkit = 'gtk3'
     else:
         widget_toolkit = toolkit.replace('cairo-', '')
     return widget_toolkit
@@ -194,6 +199,14 @@ set_config('MOZ_X11', x11)
 set_define('MOZ_X11', x11)
 add_old_configure_assignment('MOZ_X11', x11)
 
+# Wayland support
+# ==============================================================
+wayland_headers = pkg_check_modules('MOZ_WAYLAND', 'gtk+-wayland-3.0 >= 3.22',
+                                    when=wayland)
+
+set_config('MOZ_WAYLAND', depends_if(wayland_headers)(lambda _: True))
+set_define('MOZ_WAYLAND', depends_if(wayland_headers)(lambda _: True))
+
 # GL Provider
 # ==============================================================
 option('--with-gl-provider', nargs=1, help='Set GL provider backend type')
diff --git a/toolkit/xre/nsAppRunner.cpp b/toolkit/xre/nsAppRunner.cpp
index dca7611..ee36da7 100644
--- a/toolkit/xre/nsAppRunner.cpp
+++ b/toolkit/xre/nsAppRunner.cpp
@@ -246,6 +246,9 @@ nsString gAbsoluteArgv0Path;
 #include <pango/pangofc-fontmap.h>
 #endif
 #include <gtk/gtk.h>
+#ifdef MOZ_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
 #ifdef MOZ_X11
 #include <gdk/gdkx.h>
 #endif /* MOZ_X11 */
@@ -2879,7 +2882,6 @@ static const char* detectDisplay(void)
 {
   bool tryX11 = false;
   bool tryWayland = false;
-  bool tryBroadway = false;
 
   // Honor user backend selection
   const char *backend = PR_GetEnv("GDK_BACKEND");
@@ -2887,14 +2889,11 @@ static const char* detectDisplay(void)
     // Try all backends
     tryX11 = true;
     tryWayland = true;
-    tryBroadway = true;
   } else if (backend) {
     if (strstr(backend, "x11"))
       tryX11 = true;
     if (strstr(backend, "wayland"))
       tryWayland = true;
-    if (strstr(backend, "broadway"))
-      tryBroadway = true;
   }
 
   const char *display_name;
@@ -3785,9 +3784,14 @@ XREMain::XRE_mainStartup(bool* aExitFlag)
     if (saveDisplayArg) {
       SaveWordToEnv("DISPLAY", nsDependentCString(display_name));
     }
-  } else {
-    mDisableRemote = true;
   }
+#ifdef MOZ_WAYLAND
+  else if (GDK_IS_WAYLAND_DISPLAY(mGdkDisplay)) {
+    if (saveDisplayArg) {
+      SaveWordToEnv("WAYLAND_DISPLAY", nsDependentCString(display_name));
+    }
+  }
+#endif
 #endif
 #ifdef MOZ_ENABLE_XREMOTE
   // handle --remote now that xpcom is fired up
diff --git a/widget/gtk/WindowSurfaceProvider.cpp b/widget/gtk/WindowSurfaceProvider.cpp
index 526fe6a..6d5fdc0 100644
--- a/widget/gtk/WindowSurfaceProvider.cpp
+++ b/widget/gtk/WindowSurfaceProvider.cpp
@@ -11,6 +11,9 @@
 #include "WindowSurfaceX11Image.h"
 #include "WindowSurfaceX11SHM.h"
 #include "WindowSurfaceXRender.h"
+#ifdef MOZ_WAYLAND
+#include "WindowSurfaceWayland.h"
+#endif
 
 namespace mozilla {
 namespace widget {
@@ -19,11 +22,17 @@ using namespace mozilla::gfx;
 using namespace mozilla::layers;
 
 WindowSurfaceProvider::WindowSurfaceProvider()
-    : mXDisplay(nullptr)
+    : mIsX11Display(false)
+    , mXDisplay(nullptr)
     , mXWindow(0)
     , mXVisual(nullptr)
     , mXDepth(0)
     , mWindowSurface(nullptr)
+#ifdef MOZ_WAYLAND
+    , mWidget(nullptr)
+    , mWaylandDisplay(nullptr)
+    , mWaylandSurface(nullptr)
+#endif
 {
 }
 
@@ -43,7 +52,25 @@ void WindowSurfaceProvider::Initialize(
   mXWindow = aWindow;
   mXVisual = aVisual;
   mXDepth = aDepth;
+  mIsX11Display = true;
 }
+
+#ifdef MOZ_WAYLAND
+void WindowSurfaceProvider::Initialize(
+      nsWindow *aWidget,
+      wl_display *aWaylandDisplay,
+      wl_surface *aWaylandSurface)
+{
+  // We should not be initialized
+  MOZ_ASSERT(!mWaylandSurface);
+
+  mWidget = aWidget;
+  mWaylandDisplay = aWaylandDisplay;
+  mWaylandSurface = aWaylandSurface;
+  mIsX11Display = false;
+}
+#endif
+
 void WindowSurfaceProvider::CleanupResources()
 {
   mWindowSurface = nullptr;
@@ -52,30 +79,39 @@ void WindowSurfaceProvider::CleanupResources()
 UniquePtr<WindowSurface>
 WindowSurfaceProvider::CreateWindowSurface()
 {
-  // We should be initialized
-  MOZ_ASSERT(mXDisplay);
-
-  // Blit to the window with the following priority:
-  // 1. XRender (iff XRender is enabled && we are in-process)
-  // 2. MIT-SHM
-  // 3. XPutImage
+#ifdef MOZ_WAYLAND
+  if (!mIsX11Display) {
+    MOZ_ASSERT(mWaylandDisplay);
+    LOGDRAW(("Drawing to nsWindow %p using wl_surface\n", (void*)this));
+    return MakeUnique<WindowSurfaceWayland>(mWidget, mWaylandDisplay, mWaylandSurface);
+  } else
+#endif
+  {
+    // We should be initialized
+    MOZ_ASSERT(mXDisplay);
+
+    // Blit to the window with the following priority:
+    // 1. XRender (iff XRender is enabled && we are in-process)
+    // 2. MIT-SHM
+    // 3. XPutImage
 
 #ifdef MOZ_WIDGET_GTK
-  if (gfxVars::UseXRender()) {
-    LOGDRAW(("Drawing to nsWindow %p using XRender\n", (void*)this));
-    return MakeUnique<WindowSurfaceXRender>(mXDisplay, mXWindow, mXVisual, mXDepth);
-  }
+    if (gfxVars::UseXRender()) {
+      LOGDRAW(("Drawing to nsWindow %p using XRender\n", (void*)this));
+      return MakeUnique<WindowSurfaceXRender>(mXDisplay, mXWindow, mXVisual, mXDepth);
+    }
 #endif // MOZ_WIDGET_GTK
 
 #ifdef MOZ_HAVE_SHMIMAGE
-  if (nsShmImage::UseShm()) {
-    LOGDRAW(("Drawing to nsWindow %p using MIT-SHM\n", (void*)this));
-    return MakeUnique<WindowSurfaceX11SHM>(mXDisplay, mXWindow, mXVisual, mXDepth);
-  }
+    if (nsShmImage::UseShm()) {
+      LOGDRAW(("Drawing to nsWindow %p using MIT-SHM\n", (void*)this));
+      return MakeUnique<WindowSurfaceX11SHM>(mXDisplay, mXWindow, mXVisual, mXDepth);
+    }
 #endif // MOZ_HAVE_SHMIMAGE
 
-  LOGDRAW(("Drawing to nsWindow %p using XPutImage\n", (void*)this));
-  return MakeUnique<WindowSurfaceX11Image>(mXDisplay, mXWindow, mXVisual, mXDepth);
+    LOGDRAW(("Drawing to nsWindow %p using XPutImage\n", (void*)this));
+    return MakeUnique<WindowSurfaceX11Image>(mXDisplay, mXWindow, mXVisual, mXDepth);
+  }
 }
 
 already_AddRefed<gfx::DrawTarget>
@@ -93,7 +129,7 @@ WindowSurfaceProvider::StartRemoteDrawingInRegion(LayoutDeviceIntRegion& aInvali
 
   *aBufferMode = BufferMode::BUFFER_NONE;
   RefPtr<DrawTarget> dt = nullptr;
-  if (!(dt = mWindowSurface->Lock(aInvalidRegion)) &&
+  if (!(dt = mWindowSurface->Lock(aInvalidRegion)) && mIsX11Display
       !mWindowSurface->IsFallback()) {
     gfxWarningOnce() << "Failed to lock WindowSurface, falling back to XPutImage backend.";
     mWindowSurface = MakeUnique<WindowSurfaceX11Image>(mXDisplay, mXWindow, mXVisual, mXDepth);
diff --git a/widget/gtk/WindowSurfaceProvider.h b/widget/gtk/WindowSurfaceProvider.h
index 73b2303..9764180 100644
--- a/widget/gtk/WindowSurfaceProvider.h
+++ b/widget/gtk/WindowSurfaceProvider.h
@@ -12,8 +12,14 @@
 #include "mozilla/gfx/2D.h"
 #include "Units.h"
 
+#include <gdk/gdk.h>
+#ifdef MOZ_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
 #include <X11/Xlib.h> // for Window, Display, Visual, etc.
 
+class nsWindow;
+
 namespace mozilla {
 namespace widget {
 
@@ -39,6 +45,12 @@ public:
       Visual* aVisual,
       int aDepth);
 
+#ifdef MOZ_WAYLAND
+   void Initialize(nsWindow *aWidget,
+                   wl_display *aWaylandDisplay,
+                   wl_surface *aWaylandSurface);
+#endif
+
   /**
    * Releases any surfaces created by this provider.
    * This is used by X11CompositorWidget to get rid
@@ -55,12 +67,18 @@ public:
 private:
   UniquePtr<WindowSurface> CreateWindowSurface();
 
-  Display*  mXDisplay;
-  Window    mXWindow;
-  Visual*   mXVisual;
-  int       mXDepth;
-
+  // Can we access X?
+  bool        mIsX11Display;
+  Display*    mXDisplay;
+  Window      mXWindow;
+  Visual*     mXVisual;
+  int         mXDepth;
   UniquePtr<WindowSurface> mWindowSurface;
+#ifdef MOZ_WAYLAND
+  nsWindow*   mWidget;
+  wl_display* mWaylandDisplay;
+  wl_surface* mWaylandSurface;
+#endif
 };
 
 }  // namespace widget
diff --git a/widget/gtk/WindowSurfaceWayland.cpp b/widget/gtk/WindowSurfaceWayland.cpp
new file mode 100644
index 0000000..5e78d76
--- /dev/null
+++ b/widget/gtk/WindowSurfaceWayland.cpp
@@ -0,0 +1,488 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/*
+TODO:
+- do we need our event queue in mozcontainer?
+*/
+
+#include "WindowSurfaceWayland.h"
+
+#include "base/message_loop.h"          // for MessageLoop
+#include "base/task.h"                  // for NewRunnableMethod, etc
+#include "nsPrintfCString.h"
+#include "mozilla/gfx/2D.h"
+#include "mozilla/gfx/Tools.h"
+#include "gfxPlatform.h"
+#include "mozcontainer.h"
+
+#include <gdk/gdkwayland.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <assert.h>
+#include <poll.h>
+
+namespace mozilla {
+namespace widget {
+
+static WaylandDisplay *gWaylandDisplay = nullptr;
+
+void
+WaylandDisplayInit(wl_display *aDisplay)
+{
+    if (!gWaylandDisplay) {
+        gWaylandDisplay = new WaylandDisplay(aDisplay);
+    }
+}
+
+void
+WaylandDisplay::SetWaylandPixelFormat(uint32_t format)
+{
+  switch (format) {
+    case WL_SHM_FORMAT_ARGB8888:
+      mFormat = gfx::SurfaceFormat::B8G8R8A8;
+      break;
+    case WL_SHM_FORMAT_XRGB8888:
+      // TODO - We can use non-alpha formats when we need that
+    default:
+      break;
+  }
+}
+
+static void
+shm_format(void *data, wl_shm *wl_shm, uint32_t format)
+{
+  auto interface = reinterpret_cast<WaylandDisplay *>(data);
+  interface->SetWaylandPixelFormat(format);
+ }
+
+struct wl_shm_listener shm_listener = {
+  shm_format
+};
+
+static void
+global_registry_handler(void *data, wl_registry *registry, uint32_t id,
+                        const char *interface, uint32_t version)
+{
+  if (strcmp(interface, "wl_shm") == 0) {
+    auto interface = reinterpret_cast<WaylandDisplay *>(data);
+    auto shm = static_cast<wl_shm*>(
+        wl_registry_bind(registry, id, &wl_shm_interface, 1));
+    wl_proxy_set_queue((struct wl_proxy *)shm, interface->GetEventQueue());
+    wl_shm_add_listener(shm, &shm_listener, data);
+    interface->SetShm(shm);
+  }
+}
+
+static void
+global_registry_remover(void *data, wl_registry *registry, uint32_t id)
+{
+}
+
+static const struct wl_registry_listener registry_listener = {
+  global_registry_handler,
+  global_registry_remover
+};
+
+void
+WaylandDisplay::DisplayLoop()
+{
+  /* NoteThis function may dispatch other events being received on the given
+     queue. This function uses wl_display_dispatch_queue() internally.
+     If you are using wl_display_read_events() from more threads,
+     don't use this function (or make sure that calling wl_display_roundtrip_queue()
+     doesn't interfere with calling wl_display_prepare_read() and
+     wl_display_read_events()).
+  */
+  wl_display_roundtrip_queue(mDisplay, mEventQueue);
+}
+
+static void
+RunDisplayLoop(WaylandDisplay *aWaylandDisplay)
+{
+  // TODO - don't register task when firefox quits.
+  aWaylandDisplay->DisplayLoop();
+  MessageLoop::current()->PostTask(
+      NewRunnableFunction(&RunDisplayLoop, aWaylandDisplay));
+}
+
+WaylandDisplay::WaylandDisplay(wl_display *aDisplay)
+  : mDisplay(aDisplay)
+{
+  mEventQueue = wl_display_create_queue(mDisplay);
+
+  // wl_shm and wl_subcompositor are not provided by Gtk so we need
+  // to query wayland directly
+  wl_registry* registry = wl_display_get_registry(mDisplay);
+  wl_proxy_set_queue((struct wl_proxy *)registry, mEventQueue);
+  wl_registry_add_listener(registry, &registry_listener, this);
+
+  // We need two roundtrips here to get the registry info
+  wl_display_dispatch_queue(mDisplay, mEventQueue);
+  wl_display_roundtrip_queue(mDisplay, mEventQueue);
+  wl_display_roundtrip_queue(mDisplay, mEventQueue);
+
+  // We must have a valid pixel format
+  MOZ_RELEASE_ASSERT(mFormat != gfx::SurfaceFormat::UNKNOWN,
+                     "We don't have any pixel format!");
+
+  // TODO - is that correct way how to run wayland event pump?
+  MessageLoop::current()->PostTask(NewRunnableFunction(&RunDisplayLoop, this));
+}
+
+int
+WaylandShmPool::CreateTemporaryFile(int aSize)
+{
+  const char* tmppath = getenv("XDG_RUNTIME_DIR");
+  MOZ_RELEASE_ASSERT(tmppath, "Missing XDG_RUNTIME_DIR env variable.");
+
+  nsPrintfCString tmpname("%s/weston-shared-XXXXXX", tmppath);
+
+  char* filename;
+  int fd = -1;
+
+  if (tmpname.GetMutableData(&filename)) {
+      fd = mkstemp(filename);
+      if (fd >= 0) {
+          int flags = fcntl(fd, F_GETFD);
+          if (flags >= 0) {
+              fcntl(fd, F_SETFD, flags | FD_CLOEXEC);
+          }
+      }
+  }
+
+  if (fd >= 0) {
+      unlink(tmpname.get());
+  } else {
+      printf_stderr("Unable to create mapping file %s\n", filename);
+      MOZ_CRASH();
+  }
+
+#ifdef HAVE_POSIX_FALLOCATE
+  int ret = posix_fallocate(fd, 0, aSize);
+#else
+  int ret = ftruncate(fd, aSize);
+#endif
+  MOZ_RELEASE_ASSERT(ret == 0, "Mapping file allocation failed.");
+
+  return fd;
+}
+
+WaylandShmPool::WaylandShmPool(int aSize)
+{
+  mAllocatedSize = aSize;
+
+  mShmPoolFd = CreateTemporaryFile(mAllocatedSize);
+  mImageData = mmap(nullptr, mAllocatedSize,
+                     PROT_READ | PROT_WRITE, MAP_SHARED, mShmPoolFd, 0);
+  MOZ_RELEASE_ASSERT(mImageData != MAP_FAILED,
+                     "Unable to map drawing surface!");
+
+  mShmPool = wl_shm_create_pool(gWaylandDisplay->GetShm(),
+                                mShmPoolFd, mAllocatedSize);
+  wl_proxy_set_queue((struct wl_proxy *)mShmPool,
+                     gWaylandDisplay->GetEventQueue());
+}
+
+bool
+WaylandShmPool::Resize(int aSize)
+{
+  // We do size increase only
+  if (aSize <= mAllocatedSize)
+    return true;
+
+  if (ftruncate(mShmPoolFd, aSize) < 0)
+    return false;
+
+#ifdef HAVE_POSIX_FALLOCATE
+  errno = posix_fallocate(mShmPoolFd, 0, aSize);
+  if (errno != 0)
+    return false;
+#endif
+
+  wl_shm_pool_resize(mShmPool, aSize);
+
+  munmap(mImageData, mAllocatedSize);
+
+  mImageData = mmap(nullptr, aSize,
+                     PROT_READ | PROT_WRITE, MAP_SHARED, mShmPoolFd, 0);
+  if (mImageData == MAP_FAILED)
+    return false;
+
+  mAllocatedSize = aSize;
+  return true;
+}
+
+WaylandShmPool::~WaylandShmPool()
+{
+  munmap(mImageData, mAllocatedSize);
+  wl_shm_pool_destroy(mShmPool);
+  close(mShmPoolFd);
+}
+
+WaylandDisplay::~WaylandDisplay()
+{
+}
+
+static void
+buffer_release(void *data, wl_buffer *buffer)
+{
+  auto surface = reinterpret_cast<WindowBackBuffer*>(data);
+  surface->Detach();
+}
+
+static const struct wl_buffer_listener buffer_listener = {
+  buffer_release
+};
+
+void WindowBackBuffer::Create(int aWidth, int aHeight)
+{
+  MOZ_ASSERT(!IsAttached(), "We can't resize attached buffers.");
+
+  int newBufferSize = aWidth*aHeight*BUFFER_BPP;
+  mShmPool.Resize(newBufferSize);
+
+  mWaylandBuffer = wl_shm_pool_create_buffer(mShmPool.GetShmPool(), 0,
+                                            aWidth, aHeight, aWidth*BUFFER_BPP,
+                                            WL_SHM_FORMAT_ARGB8888);
+  wl_proxy_set_queue((struct wl_proxy *)mWaylandBuffer,
+                     gWaylandDisplay->GetEventQueue());
+  wl_buffer_add_listener(mWaylandBuffer, &buffer_listener, this);
+
+  mWidth = aWidth;
+  mHeight = aHeight;
+}
+
+void WindowBackBuffer::Release()
+{
+  wl_buffer_destroy(mWaylandBuffer);
+  mWidth = mHeight = 0;
+}
+
+WindowBackBuffer::WindowBackBuffer(int aWidth, int aHeight)
+ : mShmPool(aWidth*aHeight*BUFFER_BPP)
+  ,mWaylandBuffer(nullptr)
+  ,mWidth(aWidth)
+  ,mHeight(aHeight)
+  ,mAttached(false)
+{
+  Create(aWidth, aHeight);
+}
+
+WindowBackBuffer::~WindowBackBuffer()
+{
+  Release();
+}
+
+bool
+WindowBackBuffer::Resize(int aWidth, int aHeight)
+{
+  if (aWidth == mWidth && aHeight == mHeight)
+    return true;
+
+  Release();
+  Create(aWidth, aHeight);
+
+  return (mWaylandBuffer != nullptr);
+}
+
+void
+WindowBackBuffer::Attach(wl_surface* aSurface)
+{
+  wl_surface_attach(aSurface, mWaylandBuffer, 0, 0);
+  wl_surface_commit(aSurface);
+  wl_display_flush(gWaylandDisplay->GetDisplay());
+  mAttached = true;
+}
+
+void
+WindowBackBuffer::Detach()
+{
+  mAttached = false;
+}
+
+bool WindowBackBuffer::Sync(class WindowBackBuffer* aSourceBuffer)
+{
+  bool bufferSizeMatches = MatchSize(aSourceBuffer);
+  if (!bufferSizeMatches) {
+    Resize(aSourceBuffer->mWidth, aSourceBuffer->mHeight);
+  }
+
+  memcpy(mShmPool.GetImageData(), aSourceBuffer->mShmPool.GetImageData(),
+         aSourceBuffer->mWidth * aSourceBuffer->mHeight * BUFFER_BPP);
+  return true;
+}
+
+already_AddRefed<gfx::DrawTarget>
+WindowBackBuffer::Lock(const LayoutDeviceIntRegion& aRegion)
+{
+  gfx::IntRect bounds = aRegion.GetBounds().ToUnknownRect();
+  gfx::IntSize lockSize(bounds.XMost(), bounds.YMost());
+
+  return gfxPlatform::CreateDrawTargetForData(static_cast<unsigned char*>(mShmPool.GetImageData()),
+                                              lockSize,
+                                              BUFFER_BPP * mWidth,
+                                              gWaylandDisplay->GetSurfaceFormat());
+}
+
+
+static void
+frame_callback_handler(void *data, struct wl_callback *callback, uint32_t time)
+{
+    auto surface = reinterpret_cast<WindowSurfaceWayland*>(data);
+    surface->FrameCallbackHandler();
+}
+
+static const struct wl_callback_listener frame_listener = {
+    frame_callback_handler
+};
+
+WindowSurfaceWayland::WindowSurfaceWayland(nsWindow *aWidget,
+                                           wl_display *aDisplay,
+                                           wl_surface *aSurface)
+  : mWidget(aWidget)
+  , mSurface(aSurface)
+  , mFrontBuffer(nullptr)
+  , mBackBuffer(nullptr)
+  , mFrameCallback(nullptr)
+  , mDelayedCommit(false)
+  , mFullScreenDamage(false)
+{
+  MOZ_RELEASE_ASSERT(mSurface != nullptr,
+                    "We can't do anything useful without valid wl_surface.");
+  // Ensure we have valid display connection
+  WaylandDisplayInit(aDisplay);
+
+  // Make sure the drawing surface is handled by our event loop
+  // and not the default (Gdk) one to draw out of main thread.
+  wl_proxy_set_queue((struct wl_proxy *)mSurface,
+                     gWaylandDisplay->GetEventQueue());
+}
+
+WindowSurfaceWayland::~WindowSurfaceWayland()
+{
+  delete mFrontBuffer;
+  delete mBackBuffer;
+
+  if (mFrameCallback) {
+    wl_callback_destroy(mFrameCallback);
+  }
+}
+
+WindowBackBuffer*
+WindowSurfaceWayland::GetBufferToDraw(int aWidth, int aHeight)
+{
+  if (!mFrontBuffer) {
+    mFrontBuffer = new WindowBackBuffer(aWidth, aHeight);
+    mBackBuffer = new WindowBackBuffer(aWidth, aHeight);
+    return mFrontBuffer;
+  }
+
+  if (!mFrontBuffer->IsAttached()) {
+    if (!mFrontBuffer->MatchSize(aWidth, aHeight)) {
+      mFrontBuffer->Resize(aWidth, aHeight);
+    }
+    return mFrontBuffer;
+  }
+
+  // Front buffer is used by compositor, draw to back buffer
+  if (mBackBuffer->IsAttached()) {
+    NS_WARNING("No drawing buffer available");
+    return nullptr;
+  }
+
+  NS_ASSERTION(!mDelayedCommit,
+               "Uncommitted buffer switch, screen artifacts ahead.");
+
+  WindowBackBuffer *tmp = mFrontBuffer;
+  mFrontBuffer = mBackBuffer;
+  mBackBuffer = tmp;
+
+  if (mBackBuffer->MatchSize(aWidth, aHeight)) {
+    // Former front buffer has the same size as a requested one.
+    // Gecko may expect a content already drawn on screen so copy
+    // existing data to the new buffer.
+    mFrontBuffer->Sync(mBackBuffer);
+    // When buffer switches we need to damage whole screen
+    // (https://bugzilla.redhat.com/show_bug.cgi?id=1418260)
+    mFullScreenDamage = true;
+  } else {
+    // Former buffer has different size from the new request. Only resize
+    // the new buffer and leave geck to render new whole content.
+    mFrontBuffer->Resize(aWidth, aHeight);
+  }
+
+  return mFrontBuffer;
+}
+
+already_AddRefed<gfx::DrawTarget>
+WindowSurfaceWayland::Lock(const LayoutDeviceIntRegion& aRegion)
+{
+  // We allocate back buffer to widget size but return only
+  // portion requested by aRegion.
+  LayoutDeviceIntRect rect = mWidget->GetBounds();
+  WindowBackBuffer* buffer = GetBufferToDraw(rect.width,
+                                             rect.height);
+  NS_ASSERTION(buffer, "We don't have any buffer to draw to!");
+  if (!buffer) {
+    return nullptr;
+  }
+
+  return buffer->Lock(aRegion);
+}
+
+void
+WindowSurfaceWayland::Commit(const LayoutDeviceIntRegion& aInvalidRegion)
+{
+  for (auto iter = aInvalidRegion.RectIter(); !iter.Done(); iter.Next()) {
+    const mozilla::LayoutDeviceIntRect &r = iter.Get();
+    if (!mFullScreenDamage)
+      wl_surface_damage(mSurface, r.x, r.y, r.width, r.height);
+  }
+
+  if (mFullScreenDamage) {
+    LayoutDeviceIntRect rect = mWidget->GetBounds();
+    wl_surface_damage(mSurface, 0, 0, rect.width, rect.height);
+    mFullScreenDamage = false;
+  }
+
+  if (mFrameCallback) {
+    // Do nothing here - buffer will be commited to compositor
+    // in next frame callback event.
+    mDelayedCommit = true;
+    return;
+  } else  {
+    mFrameCallback = wl_surface_frame(mSurface);
+    wl_callback_add_listener(mFrameCallback, &frame_listener, this);
+
+    // There's no pending frame callback so we can draw immediately
+    // and create frame callback for possible subsequent drawing.
+    mFrontBuffer->Attach(mSurface);
+    mDelayedCommit = false;
+  }
+}
+
+void
+WindowSurfaceWayland::FrameCallbackHandler()
+{
+  if (mFrameCallback) {
+      wl_callback_destroy(mFrameCallback);
+      mFrameCallback = nullptr;
+  }
+
+  if (mDelayedCommit) {
+    // Send pending surface to compositor and register frame callback
+    // for possible subsequent drawing.
+    mFrameCallback = wl_surface_frame(mSurface);
+    wl_callback_add_listener(mFrameCallback, &frame_listener, this);
+
+    mFrontBuffer->Attach(mSurface);
+    mDelayedCommit = false;
+  }
+}
+
+}  // namespace widget
+}  // namespace mozilla
diff --git a/widget/gtk/WindowSurfaceWayland.h b/widget/gtk/WindowSurfaceWayland.h
new file mode 100644
index 0000000..6f7af42
--- /dev/null
+++ b/widget/gtk/WindowSurfaceWayland.h
@@ -0,0 +1,128 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef _MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
+#define _MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
+
+namespace mozilla {
+namespace widget {
+
+// We support only 32bpp formats
+#define BUFFER_BPP 4
+
+// Our general connection to Wayland display server,
+// holds our display connection and runs event loop.
+class WaylandDisplay {
+public:
+  WaylandDisplay(wl_display *aDisplay);
+  ~WaylandDisplay();
+
+  void                SetShm(wl_shm* aShm)   { mShm = aShm; };
+  wl_shm*             GetShm()               { return(mShm); };
+  wl_event_queue*     GetEventQueue()        { return mEventQueue; };
+  wl_display*         GetDisplay()           { return mDisplay; };
+  gfx::SurfaceFormat  GetSurfaceFormat()     { return mFormat; };
+  void                SetWaylandPixelFormat(uint32_t format);
+  void                DisplayLoop();
+
+private:
+  gfx::SurfaceFormat  mFormat;
+  wl_shm*             mShm;
+  wl_event_queue*     mEventQueue;
+  GThread*            mLoopThread;
+  wl_display*         mDisplay;
+};
+
+// Allocates and owns shared memory for Wayland drawing surfaces
+class WaylandShmPool {
+public:
+  WaylandShmPool(int aSize);
+  ~WaylandShmPool();
+
+  bool                Resize(int aSize);
+  wl_shm_pool*        GetShmPool()    { return mShmPool;   };
+  void*               GetImageData()  { return mImageData; };
+
+private:
+  int CreateTemporaryFile(int aSize);
+
+  wl_shm_pool*        mShmPool;
+  int                 mShmPoolFd;
+  int                 mAllocatedSize;
+  void*               mImageData;
+};
+
+// Holds actual graphics data for wl_surface
+class WindowBackBuffer {
+public:
+  WindowBackBuffer(int aWidth, int aHeight);
+  ~WindowBackBuffer();
+
+  already_AddRefed<gfx::DrawTarget> Lock(const LayoutDeviceIntRegion& aRegion);
+
+  void Attach(wl_surface* aSurface);
+  void Detach();
+  bool IsAttached() { return mAttached; }
+
+  bool Resize(int aWidth, int aHeight);
+  bool Sync(class WindowBackBuffer* aSourceBuffer);
+
+  bool MatchSize(int aWidth, int aHeight)
+  {
+    return aWidth == mWidth && aHeight == mHeight;
+  }
+  bool MatchSize(class WindowBackBuffer *aBuffer)
+  {
+    return aBuffer->mWidth == mWidth && aBuffer->mHeight == mHeight;
+  }
+
+private:
+  void Create(int aWidth, int aHeight);
+  void Release();
+
+  // WaylandShmPool provides actual shared memory we draw into
+  WaylandShmPool      mShmPool;
+
+  // wl_buffer is a wayland object that encapsulates the shared memory
+  // and passes it to wayland compositor by wl_surface object.
+  wl_buffer*          mWaylandBuffer;
+  int                 mWidth;
+  int                 mHeight;
+  bool                mAttached;
+};
+
+// WindowSurfaceWayland is an abstraction for wl_surface
+// and related management
+class WindowSurfaceWayland : public WindowSurface {
+public:
+  WindowSurfaceWayland(nsWindow *aWidget, wl_display *aDisplay, wl_surface *aSurface);
+  ~WindowSurfaceWayland();
+
+  already_AddRefed<gfx::DrawTarget> Lock(const LayoutDeviceIntRegion& aRegion) override;
+  void                      Commit(const LayoutDeviceIntRegion& aInvalidRegion) final;
+  void                      FrameCallbackHandler();
+
+private:
+  WindowBackBuffer*         GetBufferToDraw(int aWidth, int aHeight);
+
+  nsWindow*                 mWidget;
+
+  // The surface size is dynamically allocated by Commit() call,
+  // we store the latest size request here to optimize
+  // buffer usage and our gfx operations
+  wl_surface*               mSurface;
+
+  WindowBackBuffer*         mFrontBuffer;
+  WindowBackBuffer*         mBackBuffer;
+  wl_callback*              mFrameCallback;
+  bool                      mDelayedCommit;
+  bool                      mFullScreenDamage;
+};
+
+}  // namespace widget
+}  // namespace mozilla
+
+#endif // _MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
diff --git a/widget/gtk/X11CompositorWidget.cpp b/widget/gtk/X11CompositorWidget.cpp
index 05113a0..bec9cd5 100644
--- a/widget/gtk/X11CompositorWidget.cpp
+++ b/widget/gtk/X11CompositorWidget.cpp
@@ -21,27 +21,47 @@ X11CompositorWidget::X11CompositorWidget(const CompositorWidgetInitData& aInitDa
   // If we have a nsWindow, then grab the already existing display connection
   // If we don't, then use the init data to connect to the display
   if (aWindow) {
-    mXDisplay = aWindow->XDisplay();
+    mIsX11Display = aWindow->IsX11Display();
+#ifdef MOZ_WAYLAND
+    if (!mIsX11Display) {
+      mWaylandDisplay = aWindow->WaylandDisplay();
+	} else
+#endif
+	{
+      mXDisplay = aWindow->XDisplay();
+    }
   } else {
+#ifdef MOZ_WAYLAND
+    // TODO - not implemented
+    MOZ_CRASH();
+#endif
     mXDisplay = XOpenDisplay(aInitData.XDisplayString().get());
+  }  
+
+#ifdef MOZ_WAYLAND
+  if (!mIsX11Display) {
+    mWaylandSurface = (wl_surface *)aInitData.XWindow();
+    mProvider.Initialize(aWindow, mWaylandDisplay, mWaylandSurface);
+  } else
+#endif
+  {
+    mXWindow = (Window)aInitData.XWindow();
+
+    // Grab the window's visual and depth
+    XWindowAttributes windowAttrs;
+    XGetWindowAttributes(mXDisplay, mXWindow, &windowAttrs);
+
+    Visual*   visual = windowAttrs.visual;
+    int       depth = windowAttrs.depth;
+
+    // Initialize the window surface provider
+    mProvider.Initialize(
+      mXDisplay,
+      mXWindow,
+      visual,
+      depth
+      );
   }
-  mXWindow = (Window)aInitData.XWindow();
-
-  // Grab the window's visual and depth
-  XWindowAttributes windowAttrs;
-  XGetWindowAttributes(mXDisplay, mXWindow, &windowAttrs);
-
-  Visual*   visual = windowAttrs.visual;
-  int       depth = windowAttrs.depth;
-
-  // Initialize the window surface provider
-  mProvider.Initialize(
-    mXDisplay,
-    mXWindow,
-    visual,
-    depth
-    );
-
   mClientSize = aInitData.InitialClientSize();
 }
 
diff --git a/widget/gtk/X11CompositorWidget.h b/widget/gtk/X11CompositorWidget.h
index c0e0ede..e92de46 100644
--- a/widget/gtk/X11CompositorWidget.h
+++ b/widget/gtk/X11CompositorWidget.h
@@ -58,8 +58,13 @@ protected:
 private:
   LayoutDeviceIntSize mClientSize;
 
+  bool     mIsX11Display;
   Display* mXDisplay;
   Window   mXWindow;
+#ifdef MOZ_WAYLAND
+  wl_display* mWaylandDisplay;
+  wl_surface* mWaylandSurface;
+#endif  
   WindowSurfaceProvider mProvider;
 };
 
diff --git a/widget/gtk/moz.build b/widget/gtk/moz.build
index baccb6c..1cc8917 100644
--- a/widget/gtk/moz.build
+++ b/widget/gtk/moz.build
@@ -7,6 +7,9 @@
 if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gtk3':
     DIRS += ['mozgtk']
 
+if CONFIG['MOZ_WAYLAND']:
+    DIRS += ['mozwayland']
+
 EXPORTS += [
     'mozcontainer.h',
     'nsGTKToolkit.h',
@@ -72,6 +75,7 @@ if CONFIG['NS_PRINTING']:
 if CONFIG['MOZ_X11']:
     UNIFIED_SOURCES += [
         'nsClipboard.cpp',
+        'nsClipboardX11.cpp',
         'nsDragService.cpp',
         'WindowSurfaceProvider.cpp',
         'WindowSurfaceX11.cpp',
@@ -82,6 +86,12 @@ if CONFIG['MOZ_X11']:
         'WindowSurfaceProvider.h',
     ]
 
+if CONFIG['MOZ_WAYLAND']:
+    UNIFIED_SOURCES += [
+        'nsClipboardWayland.cpp',
+        'WindowSurfaceWayland.cpp',
+    ]
+
 if CONFIG['ACCESSIBILITY']:
     UNIFIED_SOURCES += [
         'maiRedundantObjectFactory.c',
diff --git a/widget/gtk/mozcontainer.c b/widget/gtk/mozcontainer.cpp
similarity index 71%
rename from widget/gtk/mozcontainer.c
rename to widget/gtk/mozcontainer.cpp
index 9b596e4..3e5ab6e 100644
--- a/widget/gtk/mozcontainer.c
+++ b/widget/gtk/mozcontainer.cpp
@@ -7,12 +7,18 @@
 
 #include "mozcontainer.h"
 #include <gtk/gtk.h>
+#ifdef MOZ_WAYLAND
+#include <gdk/gdkx.h>
+#include <gdk/gdkwayland.h>
+#endif
+
 #include <stdio.h>
+#include <string.h>
 
 #ifdef ACCESSIBILITY
 #include <atk/atk.h>
 #include "maiRedundantObjectFactory.h"
-#endif 
+#endif
 
 /* init methods */
 static void moz_container_class_init          (MozContainerClass *klass);
@@ -22,6 +28,9 @@ static void moz_container_init                (MozContainer      *container);
 static void moz_container_map                 (GtkWidget         *widget);
 static void moz_container_unmap               (GtkWidget         *widget);
 static void moz_container_realize             (GtkWidget         *widget);
+#if defined(MOZ_WAYLAND)
+static void moz_container_unrealize           (GtkWidget         *widget);
+#endif
 static void moz_container_size_allocate       (GtkWidget         *widget,
                                                GtkAllocation     *allocation);
 
@@ -71,7 +80,8 @@ moz_container_get_type(void)
 
         moz_container_type = g_type_register_static (GTK_TYPE_CONTAINER,
                                                      "MozContainer",
-                                                     &moz_container_info, 0);
+                                                     &moz_container_info,
+                                                     static_cast<GTypeFlags>(0));
 #ifdef ACCESSIBILITY
         /* Set a factory to return accessible object with ROLE_REDUNDANT for
          * MozContainer, so that gail won't send focus notification for it */
@@ -89,7 +99,7 @@ moz_container_new (void)
 {
     MozContainer *container;
 
-    container = g_object_new (MOZ_CONTAINER_TYPE, NULL);
+    container = static_cast<MozContainer*>(g_object_new (MOZ_CONTAINER_TYPE, nullptr));
 
     return GTK_WIDGET(container);
 }
@@ -143,6 +153,69 @@ moz_container_move (MozContainer *container, GtkWidget *child_widget,
 
 /* static methods */
 
+#if defined(MOZ_WAYLAND)
+/* We have to recreate our wl_surfaces when GdkWindow is shown,
+ * otherwise Gdk resources may not finished
+ * and gdk_wayland_window_get_wl_surface() fails.
+ */
+gboolean
+moz_container_map_wl_surface(MozContainer *container)
+{
+    if (container->subsurface)
+      return TRUE;
+
+    GdkWindow* window = gtk_widget_get_window(GTK_WIDGET(container));
+    wl_surface* gtk_surface = gdk_wayland_window_get_wl_surface(window);
+    if (!gtk_surface) {
+      // We requested the underlying wl_surface too early.
+      return FALSE;
+    }
+
+    container->subsurface =
+      wl_subcompositor_get_subsurface (container->subcompositor,
+                                       container->surface,
+                                       gtk_surface);
+    gint x, y;
+    gdk_window_get_position(window, &x, &y);
+    wl_subsurface_set_position(container->subsurface, x, y);
+    wl_subsurface_set_desync(container->subsurface);
+
+    // Don't accept input on subsurface
+    GdkDisplay* display = gtk_widget_get_display(GTK_WIDGET (container));
+    wl_compositor* compositor = gdk_wayland_display_get_wl_compositor(display);
+    wl_region* region = wl_compositor_create_region(compositor);
+    wl_surface_set_input_region(container->surface, region);
+    wl_region_destroy(region);
+    return TRUE;
+}
+
+static void
+moz_container_unmap_surface(MozContainer *container)
+{
+    g_clear_pointer(&container->subsurface, wl_subsurface_destroy);
+}
+
+static void
+moz_container_create_surface(MozContainer *container)
+{
+    GdkDisplay *display = gtk_widget_get_display(GTK_WIDGET(container));
+    if (GDK_IS_X11_DISPLAY(display))
+        return;
+
+    if (!container->surface) {
+        struct wl_compositor *compositor;
+        compositor = gdk_wayland_display_get_wl_compositor(display);
+        container->surface = wl_compositor_create_surface(compositor);
+    }
+}
+
+static void
+moz_container_delete_surface(MozContainer *container)
+{
+    g_clear_pointer(&container->surface, wl_surface_destroy);
+}
+#endif
+
 void
 moz_container_class_init (MozContainerClass *klass)
 {
@@ -154,6 +227,9 @@ moz_container_class_init (MozContainerClass *klass)
     widget_class->map = moz_container_map;
     widget_class->unmap = moz_container_unmap;
     widget_class->realize = moz_container_realize;
+#if defined(MOZ_WAYLAND)
+    widget_class->unrealize = moz_container_unrealize;
+#endif
     widget_class->size_allocate = moz_container_size_allocate;
 
     container_class->remove = moz_container_remove;
@@ -161,12 +237,56 @@ moz_container_class_init (MozContainerClass *klass)
     container_class->add = moz_container_add;
 }
 
+#if defined(MOZ_WAYLAND)
+static void
+registry_handle_global (void *data,
+                        struct wl_registry *registry,
+                        uint32_t name,
+                        const char *interface,
+                        uint32_t version)
+{
+    MozContainer *container = MOZ_CONTAINER(data);
+    if(strcmp(interface, "wl_subcompositor") == 0) {
+        container->subcompositor =
+            static_cast<wl_subcompositor*>(wl_registry_bind(registry,
+                                           name,
+                                           &wl_subcompositor_interface,
+                                           1));
+    }
+}
+
+static void
+registry_handle_global_remove (void *data,
+                               struct wl_registry *registry,
+                               uint32_t name)
+{
+}
+
+static const struct wl_registry_listener registry_listener = {
+    registry_handle_global,
+    registry_handle_global_remove
+};
+#endif
+
 void
 moz_container_init (MozContainer *container)
 {
     gtk_widget_set_can_focus(GTK_WIDGET(container), TRUE);
     gtk_container_set_resize_mode(GTK_CONTAINER(container), GTK_RESIZE_IMMEDIATE);
     gtk_widget_set_redraw_on_allocate(GTK_WIDGET(container), FALSE);
+
+#if defined(MOZ_WAYLAND)
+    {
+      GdkDisplay *gdk_display = gtk_widget_get_display(GTK_WIDGET(container));
+      if (GDK_IS_WAYLAND_DISPLAY (gdk_display)) {
+          wl_display* display = gdk_wayland_display_get_wl_display(gdk_display);
+          wl_registry* registry = wl_display_get_registry(display);
+          wl_registry_add_listener(registry, &registry_listener, container);
+          wl_display_roundtrip(display);
+          wl_display_roundtrip(display);
+        }
+    }
+#endif
 }
 
 void
@@ -184,7 +304,7 @@ moz_container_map (GtkWidget *widget)
     tmp_list = container->children;
     while (tmp_list) {
         tmp_child = ((MozContainerChild *)tmp_list->data)->widget;
-    
+
         if (gtk_widget_get_visible(tmp_child)) {
             if (!gtk_widget_get_mapped(tmp_child))
                 gtk_widget_map(tmp_child);
@@ -207,6 +327,13 @@ moz_container_unmap (GtkWidget *widget)
     if (gtk_widget_get_has_window (widget)) {
         gdk_window_hide (gtk_widget_get_window(widget));
     }
+#if defined(MOZ_WAYLAND)
+  /* Gdk/Wayland deletes underlying GdkWindow wl_surface on unmap event.
+   * Delete the wl_subsurface interface which
+   * keeps wl_surface object and it's available for reuse.
+   */
+    moz_container_unmap_surface(MOZ_CONTAINER(widget));
+#endif
 }
 
 void
@@ -231,7 +358,6 @@ moz_container_realize (GtkWidget *widget)
         attributes.wclass = GDK_INPUT_OUTPUT;
         attributes.visual = gtk_widget_get_visual (widget);
         attributes.window_type = GDK_WINDOW_CHILD;
-
 #if (MOZ_WIDGET_GTK == 2)
         attributes.colormap = gtk_widget_get_colormap (widget);
         attributes_mask |= GDK_WA_COLORMAP;
@@ -255,7 +381,20 @@ moz_container_realize (GtkWidget *widget)
 #if (MOZ_WIDGET_GTK == 2)
     widget->style = gtk_style_attach (widget->style, widget->window);
 #endif
+#if defined(MOZ_WAYLAND)
+    moz_container_create_surface(MOZ_CONTAINER(widget));
+#endif
+}
+
+#if defined(MOZ_WAYLAND)
+static void
+moz_container_unrealize (GtkWidget *widget)
+{
+  MozContainer* container = MOZ_CONTAINER(widget);
+  moz_container_unmap_surface(container);
+  moz_container_delete_surface(container);
 }
+#endif
 
 void
 moz_container_size_allocate (GtkWidget     *widget,
@@ -267,7 +406,7 @@ moz_container_size_allocate (GtkWidget     *widget,
 
     g_return_if_fail (IS_MOZ_CONTAINER (widget));
 
-    /*  printf("moz_container_size_allocate %p %d %d %d %d\n",
+      /* printf("moz_container_size_allocate %p %d %d %d %d\n",
         (void *)widget,
         allocation->x,
         allocation->y,
@@ -290,7 +429,7 @@ moz_container_size_allocate (GtkWidget     *widget,
     tmp_list = container->children;
 
     while (tmp_list) {
-        MozContainerChild *child = tmp_list->data;
+        MozContainerChild *child = static_cast<MozContainerChild*>(tmp_list->data);
 
         moz_container_allocate_child (container, child);
 
@@ -306,6 +445,14 @@ moz_container_size_allocate (GtkWidget     *widget,
                                allocation->width,
                                allocation->height);
     }
+
+#if defined(MOZ_WAYLAND)
+    if (container->subsurface) {
+        gint x, y;
+        gdk_window_get_position(gtk_widget_get_window(widget), &x, &y);
+        wl_subsurface_set_position(container->subsurface, x, y);
+      }
+#endif
 }
 
 void
@@ -363,7 +510,7 @@ moz_container_forall (GtkContainer *container, gboolean include_internals,
 {
     MozContainer *moz_container;
     GList *tmp_list;
-  
+
     g_return_if_fail (IS_MOZ_CONTAINER(container));
     g_return_if_fail (callback != NULL);
 
@@ -372,7 +519,7 @@ moz_container_forall (GtkContainer *container, gboolean include_internals,
     tmp_list = moz_container->children;
     while (tmp_list) {
         MozContainerChild *child;
-        child = tmp_list->data;
+        child = static_cast<MozContainerChild*>(tmp_list->data);
         tmp_list = tmp_list->next;
         (* callback) (child->widget, callback_data);
     }
@@ -399,8 +546,8 @@ moz_container_get_child (MozContainer *container, GtkWidget *child_widget)
     tmp_list = container->children;
     while (tmp_list) {
         MozContainerChild *child;
-    
-        child = tmp_list->data;
+
+        child = static_cast<MozContainerChild*>(tmp_list->data);
         tmp_list = tmp_list->next;
 
         if (child->widget == child_widget)
@@ -410,9 +557,16 @@ moz_container_get_child (MozContainer *container, GtkWidget *child_widget)
     return NULL;
 }
 
-static void 
+static void
 moz_container_add(GtkContainer *container, GtkWidget *widget)
 {
     moz_container_put(MOZ_CONTAINER(container), widget, 0, 0);
 }
 
+#ifdef MOZ_WAYLAND
+struct wl_surface*
+moz_container_get_wl_surface(MozContainer *container)
+{
+    return container->surface;
+}
+#endif
diff --git a/widget/gtk/mozcontainer.h b/widget/gtk/mozcontainer.h
index 23e17f7..5b1aa1a 100644
--- a/widget/gtk/mozcontainer.h
+++ b/widget/gtk/mozcontainer.h
@@ -10,10 +10,6 @@
 
 #include <gtk/gtk.h>
 
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
 /*
  * MozContainer
  *
@@ -44,7 +40,7 @@ extern "C" {
  * gtk_widget_set_parent_window should be called on the child GtkWidget before
  * it is realized.
  */
- 
+
 #define MOZ_CONTAINER_TYPE            (moz_container_get_type())
 #define MOZ_CONTAINER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), MOZ_CONTAINER_TYPE, MozContainer))
 #define MOZ_CONTAINER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), MOZ_CONTAINER_TYPE, MozContainerClass))
@@ -55,10 +51,25 @@ extern "C" {
 typedef struct _MozContainer      MozContainer;
 typedef struct _MozContainerClass MozContainerClass;
 
+/* Workaround for bug at wayland-util.h,
+ * present in wayland < 1.12
+ */
+#ifdef MOZ_WAYLAND
+struct wl_subcompositor;
+struct wl_surface;
+struct wl_subsurface;
+#endif
+
 struct _MozContainer
 {
     GtkContainer   container;
     GList         *children;
+
+#ifdef MOZ_WAYLAND
+    struct wl_subcompositor *subcompositor;
+    struct wl_surface       *surface;
+    struct wl_subsurface    *subsurface;
+#endif
 };
 
 struct _MozContainerClass
@@ -79,8 +90,9 @@ void       moz_container_move          (MozContainer *container,
                                         gint          width,
                                         gint          height);
 
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
+#ifdef MOZ_WAYLAND
+struct wl_surface * moz_container_get_wl_surface (MozContainer *container);
+gboolean            moz_container_map_wl_surface (MozContainer *container);
+#endif
 
 #endif /* __MOZ_CONTAINER_H__ */
diff --git a/widget/gtk/mozgtk/mozgtk.c b/widget/gtk/mozgtk/mozgtk.c
index d9fb938..8db92ba 100644
--- a/widget/gtk/mozgtk/mozgtk.c
+++ b/widget/gtk/mozgtk/mozgtk.c
@@ -515,11 +515,19 @@ STUB(gdk_device_manager_get_client_pointer)
 STUB(gdk_disable_multidevice)
 STUB(gdk_device_manager_list_devices)
 STUB(gdk_display_get_device_manager)
+STUB(gdk_display_get_default_seat)
 STUB(gdk_error_trap_pop_ignored)
 STUB(gdk_event_get_source_device)
+STUB(gdk_seat_grab)
+STUB(gdk_seat_ungrab)
 STUB(gdk_window_get_type)
 STUB(gdk_x11_window_get_xid)
 STUB(gdk_x11_display_get_type)
+STUB(gdk_wayland_window_get_wl_surface)
+STUB(gdk_wayland_window_set_use_custom_surface)
+STUB(gdk_wayland_display_get_wl_display)
+STUB(gdk_wayland_display_get_wl_compositor)
+STUB(gdk_wayland_display_get_type)
 STUB(gtk_box_new)
 STUB(gtk_cairo_should_draw_window)
 STUB(gtk_cairo_transform_to_window)
@@ -586,6 +594,7 @@ STUB(gtk_widget_path_iter_add_class)
 STUB(gtk_widget_path_new)
 STUB(gtk_widget_path_unref)
 STUB(gtk_widget_set_visual)
+STUB(gtk_widget_unregister_window)
 STUB(gtk_app_chooser_dialog_new_for_content_type)
 STUB(gtk_app_chooser_get_type)
 STUB(gtk_app_chooser_get_app_info)
diff --git a/widget/gtk/mozwayland/moz.build b/widget/gtk/mozwayland/moz.build
new file mode 100644
index 0000000..cc27368
--- /dev/null
+++ b/widget/gtk/mozwayland/moz.build
@@ -0,0 +1,15 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+SOURCES += [
+    'mozwayland.c',
+]
+
+SharedLibrary('mozwayland')
+
+SONAME = 'mozwayland'
+
+CFLAGS += CONFIG['TK_CFLAGS']
diff --git a/widget/gtk/mozwayland/mozwayland.c b/widget/gtk/mozwayland/mozwayland.c
new file mode 100644
index 0000000..9dbb581
--- /dev/null
+++ b/widget/gtk/mozwayland/mozwayland.c
@@ -0,0 +1,273 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/Types.h"
+#include <gtk/gtk.h>
+#include <gdk/gdkwayland.h>
+
+const struct wl_interface wl_buffer_interface;
+const struct wl_interface wl_callback_interface;
+const struct wl_interface wl_data_device_interface;
+const struct wl_interface wl_data_device_manager_interface;
+const struct wl_interface wl_keyboard_interface;
+const struct wl_interface wl_region_interface;
+const struct wl_interface wl_registry_interface;
+const struct wl_interface wl_shm_interface;
+const struct wl_interface wl_shm_pool_interface;
+const struct wl_interface wl_seat_interface;
+const struct wl_interface wl_surface_interface;
+const struct wl_interface wl_subsurface_interface;
+const struct wl_interface wl_subcompositor_interface;
+
+MOZ_EXPORT void
+wl_event_queue_destroy(struct wl_event_queue *queue)
+{
+}
+
+MOZ_EXPORT void
+wl_proxy_marshal(struct wl_proxy *p, uint32_t opcode, ...)
+{
+}
+
+MOZ_EXPORT void
+wl_proxy_marshal_array(struct wl_proxy *p, uint32_t opcode,
+		       union wl_argument *args)
+{
+}
+
+MOZ_EXPORT struct wl_proxy *
+wl_proxy_create(struct wl_proxy *factory,
+		const struct wl_interface *interface)
+{
+    return NULL;
+}
+
+MOZ_EXPORT void *
+wl_proxy_create_wrapper(void *proxy)
+{
+    return NULL;
+}
+
+MOZ_EXPORT void
+wl_proxy_wrapper_destroy(void *proxy_wrapper)
+{
+}
+
+MOZ_EXPORT struct wl_proxy *
+wl_proxy_marshal_constructor(struct wl_proxy *proxy,
+			     uint32_t opcode,
+			     const struct wl_interface *interface,
+			     ...)
+{
+   return NULL;
+}
+
+MOZ_EXPORT struct wl_proxy *
+wl_proxy_marshal_constructor_versioned(struct wl_proxy *proxy,
+				       uint32_t opcode,
+				       const struct wl_interface *interface,
+				       uint32_t version,
+				       ...)
+{
+   return NULL;
+}
+
+MOZ_EXPORT struct wl_proxy *
+wl_proxy_marshal_array_constructor(struct wl_proxy *proxy,
+				   uint32_t opcode, union wl_argument *args,
+				   const struct wl_interface *interface)
+{
+   return NULL;
+}
+
+MOZ_EXPORT struct wl_proxy *
+wl_proxy_marshal_array_constructor_versioned(struct wl_proxy *proxy,
+					     uint32_t opcode,
+					     union wl_argument *args,
+					     const struct wl_interface *interface,
+					     uint32_t version)
+{
+  return NULL;
+}
+
+MOZ_EXPORT void
+wl_proxy_destroy(struct wl_proxy *proxy)
+{
+}
+
+MOZ_EXPORT int
+wl_proxy_add_listener(struct wl_proxy *proxy,
+		      void (**implementation)(void), void *data)
+{
+   return -1;
+}
+
+MOZ_EXPORT const void *
+wl_proxy_get_listener(struct wl_proxy *proxy)
+{
+   return NULL;
+}
+
+MOZ_EXPORT int
+wl_proxy_add_dispatcher(struct wl_proxy *proxy,
+			wl_dispatcher_func_t dispatcher_func,
+			const void * dispatcher_data, void *data)
+{
+   return -1;
+}
+
+MOZ_EXPORT void
+wl_proxy_set_user_data(struct wl_proxy *proxy, void *user_data)
+{
+}
+
+MOZ_EXPORT void *
+wl_proxy_get_user_data(struct wl_proxy *proxy)
+{
+   return NULL;
+}
+
+MOZ_EXPORT uint32_t
+wl_proxy_get_version(struct wl_proxy *proxy)
+{
+   return -1;
+}
+
+MOZ_EXPORT uint32_t
+wl_proxy_get_id(struct wl_proxy *proxy)
+{
+   return -1;
+}
+
+MOZ_EXPORT const char *
+wl_proxy_get_class(struct wl_proxy *proxy)
+{
+   return NULL;
+}
+
+MOZ_EXPORT void
+wl_proxy_set_queue(struct wl_proxy *proxy, struct wl_event_queue *queue)
+{
+}
+
+MOZ_EXPORT struct wl_display *
+wl_display_connect(const char *name)
+{
+   return NULL;
+}
+
+MOZ_EXPORT struct wl_display *
+wl_display_connect_to_fd(int fd)
+{
+   return NULL;
+}
+
+MOZ_EXPORT void
+wl_display_disconnect(struct wl_display *display)
+{
+}
+
+MOZ_EXPORT int
+wl_display_get_fd(struct wl_display *display)
+{
+   return -1;
+}
+
+MOZ_EXPORT int
+wl_display_dispatch(struct wl_display *display)
+{
+   return -1;
+}
+
+MOZ_EXPORT int
+wl_display_dispatch_queue(struct wl_display *display,
+			  struct wl_event_queue *queue)
+{
+   return -1;
+}
+
+MOZ_EXPORT int
+wl_display_dispatch_queue_pending(struct wl_display *display,
+				  struct wl_event_queue *queue)
+{
+   return -1;
+}
+
+MOZ_EXPORT int
+wl_display_dispatch_pending(struct wl_display *display)
+{
+   return -1;
+}
+
+MOZ_EXPORT int
+wl_display_get_error(struct wl_display *display)
+{
+   return -1;
+}
+
+MOZ_EXPORT uint32_t
+wl_display_get_protocol_error(struct wl_display *display,
+			      const struct wl_interface **interface,
+			      uint32_t *id)
+{
+   return -1;
+}
+
+MOZ_EXPORT int
+wl_display_flush(struct wl_display *display)
+{
+   return -1;
+}
+
+MOZ_EXPORT int
+wl_display_roundtrip_queue(struct wl_display *display,
+			   struct wl_event_queue *queue)
+{
+  return -1;
+}
+
+MOZ_EXPORT int
+wl_display_roundtrip(struct wl_display *display)
+{
+   return -1;
+}
+
+MOZ_EXPORT struct wl_event_queue *
+wl_display_create_queue(struct wl_display *display)
+{
+   return NULL;
+}
+
+MOZ_EXPORT int
+wl_display_prepare_read_queue(struct wl_display *display,
+			      struct wl_event_queue *queue)
+{
+   return -1;
+}
+
+MOZ_EXPORT int
+wl_display_prepare_read(struct wl_display *display)
+{
+   return -1;
+}
+
+MOZ_EXPORT void
+wl_display_cancel_read(struct wl_display *display)
+{
+}
+
+MOZ_EXPORT int
+wl_display_read_events(struct wl_display *display)
+{
+   return -1;
+}
+
+MOZ_EXPORT void
+wl_log_set_handler_client(wl_log_func_t handler)
+{
+}
+
diff --git a/widget/gtk/nsClipboard.cpp b/widget/gtk/nsClipboard.cpp
index 053ae97..48f6ca7 100644
--- a/widget/gtk/nsClipboard.cpp
+++ b/widget/gtk/nsClipboard.cpp
@@ -9,6 +9,10 @@
 
 #include "nsArrayUtils.h"
 #include "nsClipboard.h"
+#include "nsClipboardX11.h"
+#if defined(MOZ_WAYLAND)
+#include "nsClipboardWayland.h"
+#endif
 #include "nsSupportsPrimitives.h"
 #include "nsString.h"
 #include "nsReadableUtils.h"
@@ -20,20 +24,11 @@
 #include "nsIObserverService.h"
 #include "mozilla/Services.h"
 #include "mozilla/RefPtr.h"
-#include "mozilla/TimeStamp.h"
 
 #include "imgIContainer.h"
 
 #include <gtk/gtk.h>
-
-// For manipulation of the X event queue
-#include <X11/Xlib.h>
-#include <gdk/gdkx.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <errno.h>
-#include <unistd.h>
-#include "X11UndefineNone.h"
+#include <gtk/gtkx.h>
 
 #include "mozilla/dom/EncodingUtils.h"
 #include "nsIUnicodeDecoder.h"
@@ -62,24 +57,52 @@ ConvertHTMLtoUCS2          (guchar             *data,
 static void
 GetHTMLCharset             (guchar * data, int32_t dataLength, nsCString& str);
 
+GdkAtom
+GetSelectionAtom(int32_t aWhichClipboard)
+{
+    if (aWhichClipboard == nsIClipboard::kGlobalClipboard)
+        return GDK_SELECTION_CLIPBOARD;
+
+    return GDK_SELECTION_PRIMARY;
+}
+
+// Idle timeout for receiving selection and property notify events (microsec)
+const int
+nsRetrievalContext::kClipboardTimeout = 500000;
+
+NS_IMPL_ISUPPORTS(nsRetrievalContext, nsIObserver)
 
-// Our own versions of gtk_clipboard_wait_for_contents and
-// gtk_clipboard_wait_for_text, which don't run the event loop while
-// waiting for the data.  This prevents a lot of problems related to
-// dispatching events at unexpected times.
+nsRetrievalContext::nsRetrievalContext(void)
+{
+    nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
+    if (os) {
+        os->AddObserver(this, "quit-application", false);
+    }
+}
 
-static GtkSelectionData *
-wait_for_contents          (GtkClipboard *clipboard, GdkAtom target);
+nsRetrievalContext::~nsRetrievalContext(void)
+{
+}
 
-static gchar *
-wait_for_text              (GtkClipboard *clipboard);
+NS_IMETHODIMP
+nsRetrievalContext::Observe(nsISupports *aSubject, const char *aTopic, const char16_t *aData)
+{
+    if (strcmp(aTopic, "quit-application") == 0) {
+        // application is going to quit, save clipboard content
+        Store();
+    }
+    return NS_OK;
+}
 
-static GdkFilterReturn
-selection_request_filter   (GdkXEvent *gdk_xevent,
-                            GdkEvent *event,
-                            gpointer data);
+void
+nsRetrievalContext::Store(void)
+{
+    GtkClipboard *clipboard = gtk_clipboard_get(GDK_SELECTION_CLIPBOARD);
+    gtk_clipboard_store(clipboard);
+}
 
 nsClipboard::nsClipboard()
+ : mContext(nullptr)
 {
 }
 
@@ -100,40 +123,24 @@ NS_IMPL_ISUPPORTS(nsClipboard, nsIClipboard)
 nsresult
 nsClipboard::Init(void)
 {
-    nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
-    if (!os)
-      return NS_ERROR_FAILURE;
-
-    os->AddObserver(this, "quit-application", false);
-
-    // A custom event filter to workaround attempting to dereference a null
-    // selection requestor in GTK3 versions before 3.11.3. See bug 1178799.
-#if (MOZ_WIDGET_GTK == 3) && defined(MOZ_X11)
-    if (gtk_check_version(3, 11, 3))
-        gdk_window_add_filter(nullptr, selection_request_filter, nullptr);
+    // create nsRetrievalContext
+    if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
+        mContext = new nsRetrievalContextX11();
+#if defined(MOZ_WAYLAND)
+    } else {
+        mContext = new nsRetrievalContextWayland();
 #endif
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsClipboard::Observe(nsISupports *aSubject, const char *aTopic, const char16_t *aData)
-{
-    if (strcmp(aTopic, "quit-application") == 0) {
-        // application is going to quit, save clipboard content
-        Store();
-        gdk_window_remove_filter(nullptr, selection_request_filter, nullptr);
     }
     return NS_OK;
 }
 
+
 nsresult
 nsClipboard::Store(void)
 {
     // Ask the clipboard manager to store the current clipboard content
     if (mGlobalTransferable) {
-        GtkClipboard *clipboard = gtk_clipboard_get(GDK_SELECTION_CLIPBOARD);
-        gtk_clipboard_store(clipboard);
+        mContext->Store();
     }
     return NS_OK;
 }
@@ -248,11 +255,8 @@ nsClipboard::GetData(nsITransferable *aTransferable, int32_t aWhichClipboard)
     if (!aTransferable)
         return NS_ERROR_FAILURE;
 
-    GtkClipboard *clipboard;
-    clipboard = gtk_clipboard_get(GetSelectionAtom(aWhichClipboard));
-
     guchar        *data = nullptr;
-    gint           length = 0;
+    uint32_t       length = 0;
     bool           foundData = false;
     nsAutoCString  foundFlavor;
 
@@ -276,21 +280,34 @@ nsClipboard::GetData(nsITransferable *aTransferable, int32_t aWhichClipboard)
             // Special case text/unicode since we can convert any
             // string into text/unicode
             if (!strcmp(flavorStr, kUnicodeMime)) {
-                gchar* new_text = wait_for_text(clipboard);
-                if (new_text) {
-                    // Convert utf-8 into our unicode format.
-                    NS_ConvertUTF8toUTF16 ucs2string(new_text);
-                    data = (guchar *)ToNewUnicode(ucs2string);
-                    length = ucs2string.Length() * 2;
+                nsCOMPtr<nsIInputStream> dataStream;
+                rv = mContext->GetClipboardContent(GTK_DEFAULT_MIME_TEXT,
+                                                   aWhichClipboard,
+                                                   getter_AddRefs(dataStream),
+                                                   &length);
+                if (NS_FAILED(rv)) {
+                    // If the type was text/unicode and we couldn't get
+                    // text off the clipboard, run the next loop
+                    // iteration.
+                    continue;
+                }
+
+                char* new_text = (char*)g_malloc(length);
+                uint32_t ret;
+                rv = dataStream->Read(new_text, length, &ret);
+                if(NS_FAILED(rv)) {
                     g_free(new_text);
-                    foundData = true;
-                    foundFlavor = kUnicodeMime;
-                    break;
+                    continue;
                 }
-                // If the type was text/unicode and we couldn't get
-                // text off the clipboard, run the next loop
-                // iteration.
-                continue;
+
+                // Convert utf-8 into our unicode format.
+                NS_ConvertUTF8toUTF16 ucs2string(new_text, length);
+                data = (guchar *)ToNewUnicode(ucs2string);
+                length = ucs2string.Length() * 2;
+                g_free(new_text);
+                foundData = true;
+                foundFlavor = kUnicodeMime;
+                break;
             }
 
             // For images, we must wrap the data in an nsIInputStream then return instead of break,
@@ -304,52 +321,54 @@ nsClipboard::GetData(nsITransferable *aTransferable, int32_t aWhichClipboard)
                     flavorStr.Assign(kJPEGImageMime);
                 }
 
-                GdkAtom atom = gdk_atom_intern(flavorStr, FALSE);
-
-                GtkSelectionData *selectionData = wait_for_contents(clipboard, atom);
-                if (!selectionData)
+                nsCOMPtr<nsIInputStream> byteStream;
+                rv = mContext->GetClipboardContent(flavorStr.get(), aWhichClipboard,
+                                                   getter_AddRefs(byteStream),
+                                                   &length);
+                if (NS_FAILED(rv))
                     continue;
 
-                nsCOMPtr<nsIInputStream> byteStream;
-                NS_NewByteInputStream(getter_AddRefs(byteStream), 
-                                      (const char*)gtk_selection_data_get_data(selectionData),
-                                      gtk_selection_data_get_length(selectionData), 
-                                      NS_ASSIGNMENT_COPY);
                 aTransferable->SetTransferData(flavorStr, byteStream, sizeof(nsIInputStream*));
-                gtk_selection_data_free(selectionData);
                 return NS_OK;
             }
 
-            // Get the atom for this type and try to request it off
-            // the clipboard.
-            GdkAtom atom = gdk_atom_intern(flavorStr, FALSE);
-            GtkSelectionData *selectionData;
-            selectionData = wait_for_contents(clipboard, atom);
-            if (selectionData) {
-                const guchar *clipboardData = gtk_selection_data_get_data(selectionData);
-                length = gtk_selection_data_get_length(selectionData);
+            // Try to request it off the clipboard.
+            nsCOMPtr<nsIInputStream> byteStream;
+            rv = mContext->GetClipboardContent(flavorStr.get(), aWhichClipboard,
+                                               getter_AddRefs(byteStream),
+                                               &length);
+            if (NS_SUCCEEDED(rv)) {
                 // Special case text/html since we can convert into UCS2
                 if (!strcmp(flavorStr, kHTMLMime)) {
+                    guchar *clipboardData = (guchar *)g_malloc(length);
+                    uint32_t ret;
+                    rv = byteStream->Read((char*)clipboardData, length, &ret);
+                    if(NS_FAILED(rv)) {
+                        g_free(clipboardData);
+                        continue;
+                    }
+
                     char16_t* htmlBody= nullptr;
                     int32_t htmlBodyLen = 0;
                     // Convert text/html into our unicode format
-                    ConvertHTMLtoUCS2(const_cast<guchar*>(clipboardData), length,
+                    ConvertHTMLtoUCS2(clipboardData, length,
                                       &htmlBody, htmlBodyLen);
+                    g_free(clipboardData);
+
                     // Try next data format?
                     if (!htmlBodyLen)
                         continue;
                     data = (guchar *)htmlBody;
                     length = htmlBodyLen * 2;
+
+                    foundData = true;
+                    foundFlavor = flavorStr;
+
                 } else {
-                    data = (guchar *)moz_xmalloc(length);
-                    if (!data)
-                        break;
-                    memcpy(data, clipboardData, length);
+                    aTransferable->SetTransferData(flavorStr, byteStream,
+                                                   sizeof(nsIInputStream*));
+                    return NS_OK;
                 }
-                gtk_selection_data_free(selectionData);
-                foundData = true;
-                foundFlavor = flavorStr;
-                break;
             }
         }
     }
@@ -394,63 +413,16 @@ NS_IMETHODIMP
 nsClipboard::HasDataMatchingFlavors(const char** aFlavorList, uint32_t aLength,
                                     int32_t aWhichClipboard, bool *_retval)
 {
-    if (!aFlavorList || !_retval)
-        return NS_ERROR_NULL_POINTER;
-
-    *_retval = false;
-
-    GtkSelectionData *selection_data =
-        GetTargets(GetSelectionAtom(aWhichClipboard));
-    if (!selection_data)
-        return NS_OK;
-
-    gint n_targets = 0;
-    GdkAtom *targets = nullptr;
-
-    if (!gtk_selection_data_get_targets(selection_data, 
-                                        &targets, &n_targets) ||
-        !n_targets)
-        return NS_OK;
-
-    // Walk through the provided types and try to match it to a
-    // provided type.
-    for (uint32_t i = 0; i < aLength && !*_retval; i++) {
-        // We special case text/unicode here.
-        if (!strcmp(aFlavorList[i], kUnicodeMime) && 
-            gtk_selection_data_targets_include_text(selection_data)) {
-            *_retval = true;
-            break;
-        }
-
-        for (int32_t j = 0; j < n_targets; j++) {
-            gchar *atom_name = gdk_atom_name(targets[j]);
-            if (!atom_name)
-                continue;
-
-            if (!strcmp(atom_name, aFlavorList[i]))
-                *_retval = true;
-
-            // X clipboard supports image/jpeg, but we want to emulate support
-            // for image/jpg as well
-            if (!strcmp(aFlavorList[i], kJPGImageMime) && !strcmp(atom_name, kJPEGImageMime))
-                *_retval = true;
-
-            g_free(atom_name);
-
-            if (*_retval)
-                break;
-        }
-    }
-    gtk_selection_data_free(selection_data);
-    g_free(targets);
-
-    return NS_OK;
+    return mContext->HasDataMatchingFlavors(aFlavorList, aLength,
+                                            aWhichClipboard, _retval);
 }
 
 NS_IMETHODIMP
 nsClipboard::SupportsSelectionClipboard(bool *_retval)
 {
-    *_retval = true; // yeah, unix supports the selection clipboard
+    // yeah, unix supports the selection clipboard on X11
+    // TODO Wayland
+    *_retval = GDK_IS_X11_DISPLAY(gdk_display_get_default());
     return NS_OK;
 }
 
@@ -461,24 +433,6 @@ nsClipboard::SupportsFindClipboard(bool* _retval)
   return NS_OK;
 }
 
-/* static */
-GdkAtom
-nsClipboard::GetSelectionAtom(int32_t aWhichClipboard)
-{
-    if (aWhichClipboard == kGlobalClipboard)
-        return GDK_SELECTION_CLIPBOARD;
-
-    return GDK_SELECTION_PRIMARY;
-}
-
-/* static */
-GtkSelectionData *
-nsClipboard::GetTargets(GdkAtom aWhichClipboard)
-{
-    GtkClipboard *clipboard = gtk_clipboard_get(aWhichClipboard);
-    return wait_for_contents(clipboard, gdk_atom_intern("TARGETS", FALSE));
-}
-
 nsITransferable *
 nsClipboard::GetTransferable(int32_t aWhichClipboard)
 {
@@ -801,246 +755,3 @@ void GetHTMLCharset(guchar * data, int32_t dataLength, nsCString& str)
     }
     str.AssignLiteral("UNKNOWN");
 }
-
-static void
-DispatchSelectionNotifyEvent(GtkWidget *widget, XEvent *xevent)
-{
-    GdkEvent event;
-    event.selection.type = GDK_SELECTION_NOTIFY;
-    event.selection.window = gtk_widget_get_window(widget);
-    event.selection.selection = gdk_x11_xatom_to_atom(xevent->xselection.selection);
-    event.selection.target = gdk_x11_xatom_to_atom(xevent->xselection.target);
-    event.selection.property = gdk_x11_xatom_to_atom(xevent->xselection.property);
-    event.selection.time = xevent->xselection.time;
-
-    gtk_widget_event(widget, &event);
-}
-
-static void
-DispatchPropertyNotifyEvent(GtkWidget *widget, XEvent *xevent)
-{
-    GdkWindow *window = gtk_widget_get_window(widget);
-    if ((gdk_window_get_events(window)) & GDK_PROPERTY_CHANGE_MASK) {
-        GdkEvent event;
-        event.property.type = GDK_PROPERTY_NOTIFY;
-        event.property.window = window;
-        event.property.atom = gdk_x11_xatom_to_atom(xevent->xproperty.atom);
-        event.property.time = xevent->xproperty.time;
-        event.property.state = xevent->xproperty.state;
-
-        gtk_widget_event(widget, &event);
-    }
-}
-
-struct checkEventContext
-{
-    GtkWidget *cbWidget;
-    Atom       selAtom;
-};
-
-static Bool
-checkEventProc(Display *display, XEvent *event, XPointer arg)
-{
-    checkEventContext *context = (checkEventContext *) arg;
-
-    if (event->xany.type == SelectionNotify ||
-        (event->xany.type == PropertyNotify &&
-         event->xproperty.atom == context->selAtom)) {
-
-        GdkWindow *cbWindow = 
-            gdk_x11_window_lookup_for_display(gdk_x11_lookup_xdisplay(display),
-                                              event->xany.window);
-        if (cbWindow) {
-            GtkWidget *cbWidget = nullptr;
-            gdk_window_get_user_data(cbWindow, (gpointer *)&cbWidget);
-            if (cbWidget && GTK_IS_WIDGET(cbWidget)) {
-                context->cbWidget = cbWidget;
-                return True;
-            }
-        }
-    }
-
-    return False;
-}
-
-// Idle timeout for receiving selection and property notify events (microsec)
-static const int kClipboardTimeout = 500000;
-
-static gchar* CopyRetrievedData(const gchar *aData)
-{
-    return g_strdup(aData);
-}
-
-static GtkSelectionData* CopyRetrievedData(GtkSelectionData *aData)
-{
-    // A negative length indicates that retrieving the data failed.
-    return gtk_selection_data_get_length(aData) >= 0 ?
-        gtk_selection_data_copy(aData) : nullptr;
-}
-
-class RetrievalContext {
-    ~RetrievalContext()
-    {
-        MOZ_ASSERT(!mData, "Wait() wasn't called");
-    }
-
-public:
-    NS_INLINE_DECL_REFCOUNTING(RetrievalContext)
-    enum State { INITIAL, COMPLETED, TIMED_OUT };
-
-    RetrievalContext() : mState(INITIAL), mData(nullptr) {}
-
-    /**
-     * Call this when data has been retrieved.
-     */
-    template <class T> void Complete(T *aData)
-    {
-        if (mState == INITIAL) {
-            mState = COMPLETED;
-            mData = CopyRetrievedData(aData);
-        } else {
-            // Already timed out
-            MOZ_ASSERT(mState == TIMED_OUT);
-        }
-    }
-
-    /**
-     * Spins X event loop until timing out or being completed. Returns
-     * null if we time out, otherwise returns the completed data (passing
-     * ownership to caller).
-     */
-    void *Wait();
-
-protected:
-    State mState;
-    void* mData;
-};
-
-void *
-RetrievalContext::Wait()
-{
-    if (mState == COMPLETED) { // the request completed synchronously
-        void *data = mData;
-        mData = nullptr;
-        return data;
-    }
-
-    GdkDisplay *gdkDisplay = gdk_display_get_default();
-    if (GDK_IS_X11_DISPLAY(gdkDisplay)) {
-        Display *xDisplay = GDK_DISPLAY_XDISPLAY(gdkDisplay);
-        checkEventContext context;
-        context.cbWidget = nullptr;
-        context.selAtom = gdk_x11_atom_to_xatom(gdk_atom_intern("GDK_SELECTION",
-                                                                FALSE));
-
-        // Send X events which are relevant to the ongoing selection retrieval
-        // to the clipboard widget.  Wait until either the operation completes, or
-        // we hit our timeout.  All other X events remain queued.
-
-        int select_result;
-
-        int cnumber = ConnectionNumber(xDisplay);
-        fd_set select_set;
-        FD_ZERO(&select_set);
-        FD_SET(cnumber, &select_set);
-        ++cnumber;
-        TimeStamp start = TimeStamp::Now();
-
-        do {
-            XEvent xevent;
-
-            while (XCheckIfEvent(xDisplay, &xevent, checkEventProc,
-                                 (XPointer) &context)) {
-
-                if (xevent.xany.type == SelectionNotify)
-                    DispatchSelectionNotifyEvent(context.cbWidget, &xevent);
-                else
-                    DispatchPropertyNotifyEvent(context.cbWidget, &xevent);
-
-                if (mState == COMPLETED) {
-                    void *data = mData;
-                    mData = nullptr;
-                    return data;
-                }
-            }
-
-            TimeStamp now = TimeStamp::Now();
-            struct timeval tv;
-            tv.tv_sec = 0;
-            tv.tv_usec = std::max<int32_t>(0,
-                kClipboardTimeout - (now - start).ToMicroseconds());
-            select_result = select(cnumber, &select_set, nullptr, nullptr, &tv);
-        } while (select_result == 1 ||
-                 (select_result == -1 && errno == EINTR));
-    }
-#ifdef DEBUG_CLIPBOARD
-    printf("exceeded clipboard timeout\n");
-#endif
-    mState = TIMED_OUT;
-    return nullptr;
-}
-
-static void
-clipboard_contents_received(GtkClipboard     *clipboard,
-                            GtkSelectionData *selection_data,
-                            gpointer          data)
-{
-    RetrievalContext *context = static_cast<RetrievalContext*>(data);
-    context->Complete(selection_data);
-    context->Release();
-}
-
-static GtkSelectionData *
-wait_for_contents(GtkClipboard *clipboard, GdkAtom target)
-{
-    RefPtr<RetrievalContext> context = new RetrievalContext();
-    // Balanced by Release in clipboard_contents_received
-    context.get()->AddRef();
-    gtk_clipboard_request_contents(clipboard, target,
-                                   clipboard_contents_received,
-                                   context.get());
-    return static_cast<GtkSelectionData*>(context->Wait());
-}
-
-static void
-clipboard_text_received(GtkClipboard *clipboard,
-                        const gchar  *text,
-                        gpointer      data)
-{
-    RetrievalContext *context = static_cast<RetrievalContext*>(data);
-    context->Complete(text);
-    context->Release();
-}
-
-static gchar *
-wait_for_text(GtkClipboard *clipboard)
-{
-    RefPtr<RetrievalContext> context = new RetrievalContext();
-    // Balanced by Release in clipboard_text_received
-    context.get()->AddRef();
-    gtk_clipboard_request_text(clipboard, clipboard_text_received, context.get());
-    return static_cast<gchar*>(context->Wait());
-}
-
-static GdkFilterReturn
-selection_request_filter(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
-{
-    XEvent *xevent = static_cast<XEvent*>(gdk_xevent);
-    if (xevent->xany.type == SelectionRequest) {
-        if (xevent->xselectionrequest.requestor == X11None)
-            return GDK_FILTER_REMOVE;
-
-        GdkDisplay *display = gdk_x11_lookup_xdisplay(
-                xevent->xselectionrequest.display);
-        if (!display)
-            return GDK_FILTER_REMOVE;
-
-        GdkWindow *window = gdk_x11_window_foreign_new_for_display(display,
-                xevent->xselectionrequest.requestor);
-        if (!window)
-            return GDK_FILTER_REMOVE;
-
-        g_object_unref(window);
-    }
-    return GDK_FILTER_CONTINUE;
-}
diff --git a/widget/gtk/nsClipboard.h b/widget/gtk/nsClipboard.h
index 70c866a..21c9661 100644
--- a/widget/gtk/nsClipboard.h
+++ b/widget/gtk/nsClipboard.h
@@ -10,10 +10,39 @@
 
 #include "nsIClipboard.h"
 #include "nsIObserver.h"
+#include "nsIBinaryOutputStream.h"
 #include <gtk/gtk.h>
 
-class nsClipboard : public nsIClipboard,
-                    public nsIObserver
+// Default Gtk MIME for text
+#define GTK_DEFAULT_MIME_TEXT "UTF8_STRING"
+
+class nsRetrievalContext : public nsIObserver {
+public:
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIOBSERVER
+
+    nsRetrievalContext();
+
+    NS_IMETHOD HasDataMatchingFlavors(const char** aFlavorList,
+                                      uint32_t aLength,
+                                      int32_t aWhichClipboard,
+                                      bool *_retval) = 0;
+    NS_IMETHOD GetClipboardContent(const char* aMimeType,
+                                   int32_t aWhichClipboard,
+                                   nsIInputStream** aResult,
+                                   uint32_t* aContentLength) = 0;
+
+    // Save global clipboard content to gtk
+    void  Store(void);
+
+protected:
+    virtual ~nsRetrievalContext();
+
+    // Idle timeout for receiving selection and property notify events (microsec)
+    static const int kClipboardTimeout;
+};
+
+class nsClipboard : public nsIClipboard
 {
 public:
     nsClipboard();
@@ -21,7 +50,6 @@ public:
     NS_DECL_ISUPPORTS
     
     NS_DECL_NSICLIPBOARD
-    NS_DECL_NSIOBSERVER
 
     // Make sure we are initialized, called from the factory
     // constructor
@@ -35,10 +63,6 @@ public:
 private:
     virtual ~nsClipboard();
 
-    // Utility methods
-    static GdkAtom               GetSelectionAtom (int32_t aWhichClipboard);
-    static GtkSelectionData     *GetTargets       (GdkAtom aWhichClipboard);
-
     // Save global clipboard content to gtk
     nsresult                     Store            (void);
 
@@ -52,7 +76,9 @@ private:
     nsCOMPtr<nsIClipboardOwner>  mGlobalOwner;
     nsCOMPtr<nsITransferable>    mSelectionTransferable;
     nsCOMPtr<nsITransferable>    mGlobalTransferable;
-
+    RefPtr<nsRetrievalContext>   mContext;
 };
 
+GdkAtom GetSelectionAtom(int32_t aWhichClipboard);
+
 #endif /* __nsClipboard_h_ */
diff --git a/widget/gtk/nsClipboardWayland.cpp b/widget/gtk/nsClipboardWayland.cpp
new file mode 100644
index 0000000..a7e8a21
--- /dev/null
+++ b/widget/gtk/nsClipboardWayland.cpp
@@ -0,0 +1,435 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/ArrayUtils.h"
+
+#include "nsArrayUtils.h"
+#include "nsClipboard.h"
+#include "nsClipboardWayland.h"
+#include "nsIStorageStream.h"
+#include "nsIBinaryOutputStream.h"
+#include "nsSupportsPrimitives.h"
+#include "nsString.h"
+#include "nsReadableUtils.h"
+#include "nsXPIDLString.h"
+#include "nsPrimitiveHelpers.h"
+#include "nsIServiceManager.h"
+#include "nsImageToPixbuf.h"
+#include "nsStringStream.h"
+#include "nsIObserverService.h"
+#include "mozilla/Services.h"
+#include "mozilla/RefPtr.h"
+#include "mozilla/TimeStamp.h"
+
+#include "imgIContainer.h"
+
+#include <gtk/gtk.h>
+#include <poll.h>
+#include <sys/epoll.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <gtk/gtk.h>
+#include <gdk/gdkwayland.h>
+#include <errno.h>
+
+void
+nsRetrievalContextWayland::ResetMIMETypeList(void)
+{
+  int length = mMIMETypes.Length();
+  for (int i = 0; i < length; i++) {
+      free(mMIMETypes[i]);
+  }
+  mMIMETypes.Clear();
+}
+
+void
+nsRetrievalContextWayland::AddMIMEType(const char *aMimeType)
+{
+    mMIMETypes.AppendElement(strdup(aMimeType));
+}
+
+bool
+nsRetrievalContextWayland::HasMIMEType(const char *aMimeType)
+{
+    int length = mMIMETypes.Length();
+    for (int i = 0; i < length; i++) {
+        if(strcmp(mMIMETypes[i], aMimeType) == 0)
+            return true;
+    }
+    return false;
+}
+
+bool
+nsRetrievalContextWayland::HasMIMETypeText(void)
+{
+    // Taken from gtk_targets_include_text()
+    int length = mMIMETypes.Length();
+    for (int i = 0; i < length; i++) {
+        if(strcmp(mMIMETypes[i], "UTF8_STRING") == 0 ||
+           strcmp(mMIMETypes[i], "TEXT") == 0 ||
+           strcmp(mMIMETypes[i], "COMPOUND_TEXT") == 0 ||
+           strcmp(mMIMETypes[i], "text/plain") == 0 ||
+           strcmp(mMIMETypes[i], "text/plain;charset=utf-8") == 0 ||
+           strcmp(mMIMETypes[i], "mTextPlainLocale") == 0)
+        {
+            return true;
+        }
+    }
+    return false;
+}
+
+void
+nsRetrievalContextWayland::SetDataOffer(wl_data_offer *aDataOffer)
+{
+    if(mDataOffer) {
+        wl_data_offer_destroy(mDataOffer);
+    }
+    mDataOffer = aDataOffer;
+}
+
+static void
+data_device_selection (void                  *data,
+                       struct wl_data_device *wl_data_device,
+                       struct wl_data_offer  *offer)
+{
+    nsRetrievalContextWayland *context =
+        static_cast<nsRetrievalContextWayland*>(data);
+    context->SetDataOffer(offer);
+}
+
+static void
+data_offer_offer (void                 *data,
+                  struct wl_data_offer *wl_data_offer,
+                  const char           *type)
+{
+  nsRetrievalContextWayland *context =
+      static_cast<nsRetrievalContextWayland*>(data);
+  context->AddMIMEType(type);
+}
+
+static void
+data_offer_source_actions(void *data,
+                          struct wl_data_offer *wl_data_offer,
+                          uint32_t source_actions)
+{
+}
+
+static void
+data_offer_action(void *data,
+                  struct wl_data_offer *wl_data_offer,
+                  uint32_t dnd_action)
+{
+}
+
+static const struct wl_data_offer_listener data_offer_listener = {
+    data_offer_offer,
+    data_offer_source_actions,
+    data_offer_action
+};
+
+static void
+data_device_data_offer (void                  *data,
+                        struct wl_data_device *data_device,
+                        struct wl_data_offer  *offer)
+{
+    nsRetrievalContextWayland *context =
+        static_cast<nsRetrievalContextWayland*>(data);
+
+    // We have a new fresh clipboard content
+    context->ResetMIMETypeList();
+    wl_data_offer_add_listener (offer, &data_offer_listener, data);
+}
+
+static void
+data_device_enter (void                  *data,
+                   struct wl_data_device *data_device,
+                   uint32_t               time,
+                   struct wl_surface     *surface,
+                   int32_t                x,
+                   int32_t                y,
+                   struct wl_data_offer  *offer)
+{
+}
+
+static void
+data_device_leave (void                  *data,
+                   struct wl_data_device *data_device)
+{
+}
+
+static void
+data_device_motion (void                  *data,
+                    struct wl_data_device *data_device,
+                    uint32_t               time,
+                    int32_t                x,
+                    int32_t                y)
+{
+}
+
+static void
+data_device_drop (void                  *data,
+                  struct wl_data_device *data_device)
+{
+}
+
+static const struct wl_data_device_listener data_device_listener = {
+    data_device_data_offer,
+    data_device_enter,
+    data_device_leave,
+    data_device_motion,
+    data_device_drop,
+    data_device_selection
+};
+
+static void
+keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
+                       uint32_t format, int fd, uint32_t size)
+{
+}
+
+static void
+keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
+                      uint32_t serial, struct wl_surface *surface,
+                      struct wl_array *keys)
+{
+}
+
+static void
+keyboard_handle_leave(void *data, struct wl_keyboard *keyboard,
+                      uint32_t serial, struct wl_surface *surface)
+{
+    // We lost focus so our clipboard data are outdated
+    nsRetrievalContextWayland *context =
+        static_cast<nsRetrievalContextWayland*>(data);
+
+    context->ResetMIMETypeList();
+    context->SetDataOffer(nullptr);
+}
+
+static void
+keyboard_handle_key(void *data, struct wl_keyboard *keyboard,
+                    uint32_t serial, uint32_t time, uint32_t key,
+                    uint32_t state)
+{
+}
+
+static void
+keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
+                          uint32_t serial, uint32_t mods_depressed,
+                          uint32_t mods_latched, uint32_t mods_locked,
+                          uint32_t group)
+{
+}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+    keyboard_handle_keymap,
+    keyboard_handle_enter,
+    keyboard_handle_leave,
+    keyboard_handle_key,
+    keyboard_handle_modifiers,
+};
+
+void
+nsRetrievalContextWayland::ConfigureKeyboard(wl_seat_capability caps)
+{
+  if (caps & WL_SEAT_CAPABILITY_KEYBOARD) {
+      mKeyboard = wl_seat_get_keyboard(mSeat);
+      wl_keyboard_add_listener(mKeyboard, &keyboard_listener, this);
+  } else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD)) {
+      wl_keyboard_destroy(mKeyboard);
+      mKeyboard = nullptr;
+  }
+}
+
+static void
+seat_handle_capabilities(void *data, struct wl_seat *seat,
+                         unsigned int caps)
+{
+    nsRetrievalContextWayland *context =
+        static_cast<nsRetrievalContextWayland*>(data);
+    context->ConfigureKeyboard((wl_seat_capability)caps);
+}
+
+static const struct wl_seat_listener seat_listener = {
+      seat_handle_capabilities,
+};
+
+void
+nsRetrievalContextWayland::InitDataDeviceManager(wl_registry *registry,
+                                                 uint32_t id,
+                                                 uint32_t version)
+{
+  int data_device_manager_version = MIN (version, 3);
+  mDataDeviceManager = (wl_data_device_manager *)wl_registry_bind(registry, id,
+      &wl_data_device_manager_interface, data_device_manager_version);
+}
+
+void nsRetrievalContextWayland::InitSeat(wl_registry *registry,
+                                         uint32_t id, uint32_t version,
+                                         void *data)
+{
+  mSeat = (wl_seat*)wl_registry_bind(registry, id, &wl_seat_interface, 1);
+  wl_seat_add_listener(mSeat, &seat_listener, data);
+}
+
+static void
+gdk_registry_handle_global(void               *data,
+                           struct wl_registry *registry,
+                           uint32_t            id,
+                           const char         *interface,
+                           uint32_t            version)
+{
+  nsRetrievalContextWayland *context =
+      static_cast<nsRetrievalContextWayland*>(data);
+
+  if (strcmp (interface, "wl_data_device_manager") == 0) {
+    context->InitDataDeviceManager(registry, id, version);
+  } else if (strcmp(interface, "wl_seat") == 0) {
+    context->InitSeat(registry, id, version, data);
+  }
+}
+
+static void
+gdk_registry_handle_global_remove(void               *data,
+                                 struct wl_registry *registry,
+                                 uint32_t            id)
+{
+}
+
+static const struct wl_registry_listener clipboard_registry_listener = {
+    gdk_registry_handle_global,
+    gdk_registry_handle_global_remove
+};
+
+nsRetrievalContextWayland::nsRetrievalContextWayland(void)
+  : mInitialized(false),
+    mDataDeviceManager(nullptr),
+    mDataOffer(nullptr)
+{
+    const gchar* charset;
+    g_get_charset(&charset);
+    mTextPlainLocale = g_strdup_printf("text/plain;charset=%s", charset);
+
+    mDisplay = gdk_wayland_display_get_wl_display(gdk_display_get_default());
+    wl_registry_add_listener(wl_display_get_registry(mDisplay),
+                             &clipboard_registry_listener, this);
+    wl_display_roundtrip(mDisplay);
+
+    // We don't have Wayland support here so just give up
+    if (!mDataDeviceManager || !mSeat)
+        return;
+
+    wl_data_device *dataDevice =
+        wl_data_device_manager_get_data_device(mDataDeviceManager, mSeat);
+    wl_data_device_add_listener(dataDevice, &data_device_listener, this);
+    wl_display_roundtrip(mDisplay);
+
+    mInitialized = true;
+}
+
+nsRetrievalContextWayland::~nsRetrievalContextWayland(void)
+{
+    g_free(mTextPlainLocale);
+}
+
+NS_IMETHODIMP
+nsRetrievalContextWayland::HasDataMatchingFlavors(const char** aFlavorList,
+    uint32_t aLength, int32_t aWhichClipboard, bool *_retval)
+{
+    if (!aFlavorList || !_retval)
+        return NS_ERROR_NULL_POINTER;
+
+    *_retval = false;
+
+    // Walk through the provided types and try to match it to a
+    // provided type.
+    for (uint32_t i = 0; i < aLength; i++) {
+        // We special case text/unicode here.
+        if (!strcmp(aFlavorList[i], kUnicodeMime) &&
+            HasMIMETypeText()) {
+            *_retval = true;
+            break;
+        }
+        if (HasMIMEType(aFlavorList[i])) {
+            *_retval = true;
+            break;
+        }
+        // X clipboard supports image/jpeg, but we want to emulate support
+        // for image/jpg as well
+        if (!strcmp(aFlavorList[i], kJPGImageMime) &&
+            HasMIMEType(kJPEGImageMime)) {
+            *_retval = true;
+            break;
+        }
+    }
+
+    return NS_OK;
+}
+
+nsresult
+nsRetrievalContextWayland::GetClipboardContent(const char* aMimeType,
+                                               int32_t aWhichClipboard,
+                                               nsIInputStream** aResult,
+                                               uint32_t* aContentLength)
+{
+    NS_ASSERTION(mDataOffer, "Requested data without valid data offer!");
+
+    int pipe_fd[2];
+    if (pipe(pipe_fd) == -1)
+        return NS_ERROR_FAILURE;
+
+    wl_data_offer_receive(mDataOffer, aMimeType, pipe_fd[1]);
+    close(pipe_fd[1]);
+    wl_display_flush(mDisplay);
+
+    nsresult rv;
+    nsCOMPtr<nsIStorageStream> storageStream;
+    nsCOMPtr<nsIBinaryOutputStream> stream;
+    int length;
+
+    struct pollfd fds;
+    fds.fd = pipe_fd[0];
+    fds.events = POLLIN;
+
+    // Choose some reasonable timeout here
+    int ret = poll(&fds, 1, kClipboardTimeout*1000);
+    if (!ret || ret == -1) {
+        close(pipe_fd[0]);
+        return NS_ERROR_FAILURE;
+    }
+
+    #define BUFFER_SIZE 4096
+
+    NS_NewStorageStream(BUFFER_SIZE, UINT32_MAX, getter_AddRefs(storageStream));
+    nsCOMPtr<nsIOutputStream> outputStream;
+    rv = storageStream->GetOutputStream(0, getter_AddRefs(outputStream));
+    if (NS_FAILED(rv)) {
+        close(pipe_fd[0]);
+        return NS_ERROR_FAILURE;
+    }
+
+    do {
+        char buffer[BUFFER_SIZE];
+        length = read(pipe_fd[0], buffer, sizeof(buffer));
+        if (length == 0 || length == -1)
+            break;
+
+        uint32_t ret;
+        rv = outputStream->Write(buffer, length, &ret);
+    } while(NS_SUCCEEDED(rv) && length == BUFFER_SIZE);
+
+    outputStream->Close();
+    close(pipe_fd[0]);
+
+    rv = storageStream->GetLength(aContentLength);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = storageStream->NewInputStream(0, aResult);
+    NS_ENSURE_SUCCESS(rv, rv);
+    return NS_OK;
+}
diff --git a/widget/gtk/nsClipboardWayland.h b/widget/gtk/nsClipboardWayland.h
new file mode 100644
index 0000000..0feede8
--- /dev/null
+++ b/widget/gtk/nsClipboardWayland.h
@@ -0,0 +1,53 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsClipboardWayland_h_
+#define __nsClipboardWayland_h_
+
+#include "nsIClipboard.h"
+#include <gtk/gtk.h>
+#include <gdk/gdkwayland.h>
+#include <nsTArray.h>
+
+class nsRetrievalContextWayland : public nsRetrievalContext
+{
+public:
+    nsRetrievalContextWayland();
+
+    NS_IMETHOD HasDataMatchingFlavors(const char** aFlavorList,
+                                      uint32_t aLength,
+                                      int32_t aWhichClipboard,
+                                      bool *_retval) override;
+    NS_IMETHOD GetClipboardContent(const char* aMimeType,
+                                   int32_t aWhichClipboard,
+                                   nsIInputStream** aResult,
+                                   uint32_t* aContentLength) override;
+
+    void SetDataOffer(wl_data_offer *aDataOffer);
+    void AddMIMEType(const char *aMimeType);
+    bool HasMIMEType(const char *aMimeType);
+    // Our version of gtk_selection_data_targets_include_text()
+    bool HasMIMETypeText(void);
+    void ResetMIMETypeList(void);
+    void ConfigureKeyboard(wl_seat_capability caps);
+
+    void InitDataDeviceManager(wl_registry *registry, uint32_t id, uint32_t version);
+    void InitSeat(wl_registry *registry, uint32_t id, uint32_t version, void *data);
+private:
+    virtual ~nsRetrievalContextWayland() override;
+
+    bool                    mInitialized;
+    wl_display             *mDisplay;
+    wl_seat                *mSeat;
+    wl_data_device_manager *mDataDeviceManager;
+    wl_data_offer          *mDataOffer;
+    wl_keyboard            *mKeyboard;
+    nsTArray<char*>         mMIMETypes;
+    gchar                  *mTextPlainLocale;
+};
+
+#endif /* __nsClipboardWayland_h_ */
diff --git a/widget/gtk/nsClipboardX11.cpp b/widget/gtk/nsClipboardX11.cpp
new file mode 100644
index 0000000..45c6d9f
--- /dev/null
+++ b/widget/gtk/nsClipboardX11.cpp
@@ -0,0 +1,309 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/ArrayUtils.h"
+
+#include "nsArrayUtils.h"
+#include "nsClipboard.h"
+#include "nsClipboardX11.h"
+#include "nsSupportsPrimitives.h"
+#include "nsString.h"
+#include "nsReadableUtils.h"
+#include "nsXPIDLString.h"
+#include "nsPrimitiveHelpers.h"
+#include "nsIServiceManager.h"
+#include "nsImageToPixbuf.h"
+#include "nsStringStream.h"
+#include "nsIObserverService.h"
+#include "mozilla/Services.h"
+#include "mozilla/RefPtr.h"
+#include "mozilla/TimeStamp.h"
+
+#include "imgIContainer.h"
+
+#include <gtk/gtk.h>
+
+// For manipulation of the X event queue
+#include <X11/Xlib.h>
+#include <gdk/gdkx.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <unistd.h>
+#include "X11UndefineNone.h"
+
+using namespace mozilla;
+
+static GdkFilterReturn
+selection_request_filter(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
+{
+    XEvent *xevent = static_cast<XEvent*>(gdk_xevent);
+    if (xevent->xany.type == SelectionRequest) {
+        if (xevent->xselectionrequest.requestor == X11None)
+            return GDK_FILTER_REMOVE;
+
+        GdkDisplay *display = gdk_x11_lookup_xdisplay(
+                xevent->xselectionrequest.display);
+        if (!display)
+            return GDK_FILTER_REMOVE;
+
+        GdkWindow *window = gdk_x11_window_foreign_new_for_display(display,
+                xevent->xselectionrequest.requestor);
+        if (!window)
+            return GDK_FILTER_REMOVE;
+
+        g_object_unref(window);
+    }
+    return GDK_FILTER_CONTINUE;
+}
+
+nsRetrievalContextX11::nsRetrievalContextX11(void)
+: mState(INITIAL),
+  mData(nullptr)
+{
+    // A custom event filter to workaround attempting to dereference a null
+    // selection requestor in GTK3 versions before 3.11.3. See bug 1178799.
+#if (MOZ_WIDGET_GTK == 3) && defined(MOZ_X11)
+    if (gtk_check_version(3, 11, 3))
+        gdk_window_add_filter(nullptr, selection_request_filter, nullptr);
+#endif
+}
+
+nsRetrievalContextX11::~nsRetrievalContextX11(void)
+{
+    gdk_window_remove_filter(nullptr, selection_request_filter, nullptr);
+}
+
+static void
+DispatchSelectionNotifyEvent(GtkWidget *widget, XEvent *xevent)
+{
+    GdkEvent event;
+    event.selection.type = GDK_SELECTION_NOTIFY;
+    event.selection.window = gtk_widget_get_window(widget);
+    event.selection.selection = gdk_x11_xatom_to_atom(xevent->xselection.selection);
+    event.selection.target = gdk_x11_xatom_to_atom(xevent->xselection.target);
+    event.selection.property = gdk_x11_xatom_to_atom(xevent->xselection.property);
+    event.selection.time = xevent->xselection.time;
+
+    gtk_widget_event(widget, &event);
+}
+
+static void
+DispatchPropertyNotifyEvent(GtkWidget *widget, XEvent *xevent)
+{
+    GdkWindow *window = gtk_widget_get_window(widget);
+    if ((gdk_window_get_events(window)) & GDK_PROPERTY_CHANGE_MASK) {
+        GdkEvent event;
+        event.property.type = GDK_PROPERTY_NOTIFY;
+        event.property.window = window;
+        event.property.atom = gdk_x11_xatom_to_atom(xevent->xproperty.atom);
+        event.property.time = xevent->xproperty.time;
+        event.property.state = xevent->xproperty.state;
+
+        gtk_widget_event(widget, &event);
+    }
+}
+
+struct checkEventContext
+{
+    GtkWidget *cbWidget;
+    Atom       selAtom;
+};
+
+static Bool
+checkEventProc(Display *display, XEvent *event, XPointer arg)
+{
+    checkEventContext *context = (checkEventContext *) arg;
+
+    if (event->xany.type == SelectionNotify ||
+        (event->xany.type == PropertyNotify &&
+         event->xproperty.atom == context->selAtom)) {
+
+        GdkWindow *cbWindow =
+            gdk_x11_window_lookup_for_display(gdk_x11_lookup_xdisplay(display),
+                                              event->xany.window);
+        if (cbWindow) {
+            GtkWidget *cbWidget = nullptr;
+            gdk_window_get_user_data(cbWindow, (gpointer *)&cbWidget);
+            if (cbWidget && GTK_IS_WIDGET(cbWidget)) {
+                context->cbWidget = cbWidget;
+                return True;
+            }
+        }
+    }
+
+    return False;
+}
+
+void *
+nsRetrievalContextX11::Wait()
+{
+    if (mState == COMPLETED) { // the request completed synchronously
+        void *data = mData;
+        mData = nullptr;
+        return data;
+    }
+
+    GdkDisplay *gdkDisplay = gdk_display_get_default();
+    if (GDK_IS_X11_DISPLAY(gdkDisplay)) {
+        Display *xDisplay = GDK_DISPLAY_XDISPLAY(gdkDisplay);
+        checkEventContext context;
+        context.cbWidget = nullptr;
+        context.selAtom = gdk_x11_atom_to_xatom(gdk_atom_intern("GDK_SELECTION",
+                                                                FALSE));
+
+        // Send X events which are relevant to the ongoing selection retrieval
+        // to the clipboard widget.  Wait until either the operation completes, or
+        // we hit our timeout.  All other X events remain queued.
+
+        int select_result;
+
+        int cnumber = ConnectionNumber(xDisplay);
+        fd_set select_set;
+        FD_ZERO(&select_set);
+        FD_SET(cnumber, &select_set);
+        ++cnumber;
+        TimeStamp start = TimeStamp::Now();
+
+        do {
+            XEvent xevent;
+
+            while (XCheckIfEvent(xDisplay, &xevent, checkEventProc,
+                                 (XPointer) &context)) {
+
+                if (xevent.xany.type == SelectionNotify)
+                    DispatchSelectionNotifyEvent(context.cbWidget, &xevent);
+                else
+                    DispatchPropertyNotifyEvent(context.cbWidget, &xevent);
+
+                if (mState == COMPLETED) {
+                    void *data = mData;
+                    mData = nullptr;
+                    return data;
+                }
+            }
+
+            TimeStamp now = TimeStamp::Now();
+            struct timeval tv;
+            tv.tv_sec = 0;
+            tv.tv_usec = std::max<int32_t>(0,
+                kClipboardTimeout - (now - start).ToMicroseconds());
+            select_result = select(cnumber, &select_set, nullptr, nullptr, &tv);
+        } while (select_result == 1 ||
+                 (select_result == -1 && errno == EINTR));
+    }
+#ifdef DEBUG_CLIPBOARD
+    printf("exceeded clipboard timeout\n");
+#endif
+    mState = TIMED_OUT;
+    return nullptr;
+}
+
+static void
+clipboard_contents_received(GtkClipboard     *clipboard,
+                            GtkSelectionData *selection_data,
+                            gpointer          data)
+{
+    nsRetrievalContextX11 *context = static_cast<nsRetrievalContextX11*>(data);
+    context->Complete(selection_data);
+}
+
+GtkSelectionData*
+nsRetrievalContextX11::WaitForContents(GtkClipboard *clipboard, const char *aMimeType)
+{
+    mState = INITIAL;
+    NS_ASSERTION(!mData, "Leaking clipboard content!");
+
+    gtk_clipboard_request_contents(clipboard,
+                                   gdk_atom_intern(aMimeType, FALSE),
+                                   clipboard_contents_received,
+                                   this);
+    return static_cast<GtkSelectionData*>(Wait());
+}
+
+NS_IMETHODIMP
+nsRetrievalContextX11::HasDataMatchingFlavors(const char** aFlavorList,
+                                              uint32_t aLength,
+                                              int32_t aWhichClipboard,
+                                              bool *_retval)
+{
+    if (!aFlavorList || !_retval)
+        return NS_ERROR_NULL_POINTER;
+
+    *_retval = false;
+
+    GtkClipboard *clipboard = 
+        gtk_clipboard_get(GetSelectionAtom(aWhichClipboard));
+
+    GtkSelectionData *selection_data =
+        WaitForContents(clipboard, "TARGETS");
+    if (!selection_data)
+        return NS_OK;
+
+    gint n_targets = 0;
+    GdkAtom *targets = nullptr;
+
+    if (!gtk_selection_data_get_targets(selection_data,
+                                        &targets, &n_targets) ||
+        !n_targets)
+        return NS_OK;
+
+    // Walk through the provided types and try to match it to a
+    // provided type.
+    for (uint32_t i = 0; i < aLength && !*_retval; i++) {
+        // We special case text/unicode here.
+        if (!strcmp(aFlavorList[i], kUnicodeMime) &&
+            gtk_selection_data_targets_include_text(selection_data)) {
+            *_retval = true;
+            break;
+        }
+
+        for (int32_t j = 0; j < n_targets; j++) {
+            gchar *atom_name = gdk_atom_name(targets[j]);
+            if (!atom_name)
+                continue;
+
+            if (!strcmp(atom_name, aFlavorList[i]))
+                *_retval = true;
+
+            // X clipboard supports image/jpeg, but we want to emulate support
+            // for image/jpg as well
+            if (!strcmp(aFlavorList[i], kJPGImageMime) && !strcmp(atom_name, kJPEGImageMime))
+                *_retval = true;
+
+            g_free(atom_name);
+
+            if (*_retval)
+                break;
+        }
+    }
+    gtk_selection_data_free(selection_data);
+    g_free(targets);
+
+    return NS_OK;
+}
+
+nsresult
+nsRetrievalContextX11::GetClipboardContent(const char* aMimeType,
+                                           int32_t aWhichClipboard,
+                                           nsIInputStream** aResult,
+                                           uint32_t* aContentLength)
+{
+    GtkClipboard *clipboard;
+    clipboard = gtk_clipboard_get(GetSelectionAtom(aWhichClipboard));
+
+    GtkSelectionData *selectionData = WaitForContents(clipboard, aMimeType);
+    if (!selectionData)
+        return NS_ERROR_FAILURE;
+
+    *aContentLength = gtk_selection_data_get_length(selectionData);
+    NS_NewByteInputStream(aResult,
+                          (const char*)gtk_selection_data_get_data(selectionData),
+                          *aContentLength, NS_ASSIGNMENT_COPY);
+    gtk_selection_data_free(selectionData);
+    return NS_OK;
+}
diff --git a/widget/gtk/nsClipboardX11.h b/widget/gtk/nsClipboardX11.h
new file mode 100644
index 0000000..f9eb0d3
--- /dev/null
+++ b/widget/gtk/nsClipboardX11.h
@@ -0,0 +1,68 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsClipboardX11_h_
+#define __nsClipboardX11_h_
+
+#include "nsIClipboard.h"
+#include <gtk/gtk.h>
+
+class nsRetrievalContextX11 : public nsRetrievalContext
+{
+public:
+    enum State { INITIAL, COMPLETED, TIMED_OUT };
+
+    nsRetrievalContextX11();
+
+    NS_IMETHOD HasDataMatchingFlavors(const char** aFlavorList,
+                                      uint32_t aLength,
+                                      int32_t aWhichClipboard,
+                                      bool *_retval) override;
+    NS_IMETHOD GetClipboardContent(const char* aMimeType,
+                                   int32_t aWhichClipboard,
+                                   nsIInputStream** aResult,
+                                   uint32_t* aContentLength) override;
+
+    gchar* CopyRetrievedData(const gchar *aData)
+    {
+      return g_strdup(aData);
+    }
+    GtkSelectionData* CopyRetrievedData(GtkSelectionData *aData)
+    {
+      // A negative length indicates that retrieving the data failed.
+      return gtk_selection_data_get_length(aData) >= 0 ?
+          gtk_selection_data_copy(aData) : nullptr;
+    }
+
+    // Call this when data has been retrieved.
+    template <class T> void Complete(T *aData)
+    {
+      if (mState == INITIAL) {
+          mState = COMPLETED;
+          mData = CopyRetrievedData(aData);
+      } else {
+          // Already timed out
+          MOZ_ASSERT(mState == TIMED_OUT);
+      }
+    }
+private:
+    virtual ~nsRetrievalContextX11() override;
+
+    GtkSelectionData* WaitForContents(GtkClipboard *clipboard,
+                                      const char *aMimeType);
+    /**
+     * Spins X event loop until timing out or being completed. Returns
+     * null if we time out, otherwise returns the completed data (passing
+     * ownership to caller).
+     */
+    void *Wait();
+
+    State mState;
+    void* mData;
+};
+
+#endif /* __nsClipboardX11_h_ */
diff --git a/widget/gtk/nsNativeThemeGTK.cpp b/widget/gtk/nsNativeThemeGTK.cpp
index 89b8ab7..a6e6558 100644
--- a/widget/gtk/nsNativeThemeGTK.cpp
+++ b/widget/gtk/nsNativeThemeGTK.cpp
@@ -7,6 +7,7 @@
 #include "nsThemeConstants.h"
 #include "gtkdrawing.h"
 #include "nsScreenGtk.h"
+#include "X11UndefineNone.h"
 
 #include "gfx2DGlue.h"
 #include "nsIObserverService.h"
@@ -30,6 +31,7 @@
 
 #include <gdk/gdkprivate.h>
 #include <gtk/gtk.h>
+#include <gtk/gtkx.h>
 
 #include "gfxContext.h"
 #include "gfxPlatformGtk.h"
@@ -1212,7 +1214,11 @@ nsNativeThemeGTK::DrawWidgetBackground(nsRenderingContext* aContext,
 #endif
 
   if (!safeState) {
-    gdk_flush();
+    // gdk_flush() call from expose event crashes Gtk+ on Wayland
+    // (Gnome BZ #773307)
+    if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
+      gdk_flush();
+    }
     gLastGdkError = gdk_error_trap_pop ();
 
     if (gLastGdkError) {
diff --git a/widget/gtk/nsNativeThemeGTK.h b/widget/gtk/nsNativeThemeGTK.h
index 56ae031..7ad7c17 100644
--- a/widget/gtk/nsNativeThemeGTK.h
+++ b/widget/gtk/nsNativeThemeGTK.h
@@ -6,6 +6,7 @@
 #ifndef _GTK_NSNATIVETHEMEGTK_H_
 #define _GTK_NSNATIVETHEMEGTK_H_
 
+#include "X11UndefineNone.h"
 #include "nsITheme.h"
 #include "nsCOMPtr.h"
 #include "nsIAtom.h"
diff --git a/widget/gtk/nsScreenGtk.cpp b/widget/gtk/nsScreenGtk.cpp
index 61e6605..28e7f23 100644
--- a/widget/gtk/nsScreenGtk.cpp
+++ b/widget/gtk/nsScreenGtk.cpp
@@ -50,7 +50,7 @@ nsScreenGtk :: GetRect(int32_t *outLeft, int32_t *outTop, int32_t *outWidth, int
   *outHeight = mRect.height;
 
   return NS_OK;
-  
+
 } // GetRect
 
 
@@ -63,7 +63,7 @@ nsScreenGtk :: GetAvailRect(int32_t *outLeft, int32_t *outTop, int32_t *outWidth
   *outHeight = mAvailRect.height;
 
   return NS_OK;
-  
+
 } // GetAvailRect
 
 gint
@@ -93,7 +93,7 @@ nsScreenGtk :: GetDPIScale()
   return dpiScale;
 }
 
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsScreenGtk :: GetPixelDepth(int32_t *aPixelDepth)
 {
   GdkVisual * visual = gdk_screen_get_system_visual(gdk_screen_get_default());
@@ -103,7 +103,7 @@ nsScreenGtk :: GetPixelDepth(int32_t *aPixelDepth)
 
 } // GetPixelDepth
 
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsScreenGtk :: GetColorDepth(int32_t *aColorDepth)
 {
   return GetPixelDepth ( aColorDepth );
@@ -130,6 +130,8 @@ nsScreenGtk :: Init (GdkWindow *aRootWindow)
   // versions of GDK predating the GdkScreen object.  See bug 256646.
   mAvailRect = mRect = nsIntRect(0, 0, width, height);
 
+  return;
+
 #ifdef MOZ_X11
   // We need to account for the taskbar, etc in the available rect.
   // See http://freedesktop.org/Standards/wm-spec/index.html#id2767771
diff --git a/widget/gtk/nsWindow.cpp b/widget/gtk/nsWindow.cpp
index d97b350..9942399 100644
--- a/widget/gtk/nsWindow.cpp
+++ b/widget/gtk/nsWindow.cpp
@@ -5,6 +5,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include <assert.h>
 #include "nsWindow.h"
 
 #include "mozilla/ArrayUtils.h"
@@ -58,6 +59,10 @@
 #include <gtk/gtkprivate.h>
 #endif
 
+#if defined(MOZ_WAYLAND)
+#include <gdk/gdkwayland.h>
+#endif
+
 #include "nsGkAtoms.h"
 
 #ifdef MOZ_ENABLE_STARTUP_NOTIFICATION
@@ -457,7 +462,9 @@ nsWindow::nsWindow()
     mXVisual  = nullptr;
     mXDepth   = 0;
 #endif /* MOZ_X11 */
-    mPluginType          = PluginType_NONE;
+#ifdef MOZ_WAYLAND
+    mWaylandSurface = nullptr;
+#endif
 
     if (!gGlobalsInitialized) {
         gGlobalsInitialized = true;
@@ -1390,6 +1397,9 @@ SetUserTimeAndStartupIDForActivatedWindow(GtkWidget* aWindow)
 /* static */ guint32
 nsWindow::GetLastUserInputTime()
 {
+    if (!GDK_IS_X11_DISPLAY(gdk_display_get_default()))
+        return sLastUserInputTime;
+
     // gdk_x11_display_get_user_time tracks button and key presses,
     // DESKTOP_STARTUP_ID used to start the app, drop events from external
     // drags, WM_DELETE_WINDOW delete events, but not usually mouse motion nor
@@ -1740,12 +1750,17 @@ nsWindow::GetNativeData(uint32_t aDataType)
         return (void*)mPluginNativeWindow->window;
 
     case NS_NATIVE_DISPLAY: {
-#ifdef MOZ_X11
         GdkDisplay* gdkDisplay = gdk_display_get_default();
+#if defined(MOZ_X11)
         if (GDK_IS_X11_DISPLAY(gdkDisplay)) {
           return GDK_DISPLAY_XDISPLAY(gdkDisplay);
         }
-#endif /* MOZ_X11 */
+#endif
+#if defined(MOZ_WAYLAND)
+        if (GDK_IS_WAYLAND_DISPLAY(gdkDisplay)) {
+          return gdk_wayland_display_get_wl_display(gdkDisplay);
+        }
+#endif
         return nullptr;
     }
     case NS_NATIVE_SHELLWIDGET:
@@ -1769,10 +1784,10 @@ nsWindow::GetNativeData(uint32_t aDataType)
     }
     case NS_NATIVE_OPENGL_CONTEXT:
       return nullptr;
-#ifdef MOZ_X11
+#if defined(MOZ_X11)
     case NS_NATIVE_COMPOSITOR_DISPLAY:
         return gfxPlatformGtk::GetPlatform()->GetCompositorDisplay();
-#endif // MOZ_X11
+#endif
     default:
         NS_WARNING("nsWindow::GetNativeData called with bad value");
         return nullptr;
@@ -2139,6 +2154,12 @@ nsWindow::OnExposeEvent(cairo_t *cr)
     if (!listener)
         return FALSE;
 
+#ifdef MOZ_WAYLAND
+    // We don't have any Wayland surface to paint to
+    if (mContainer && !mIsX11Display && !moz_container_map_wl_surface(mContainer))
+        return FALSE;
+#endif
+
     LayoutDeviceIntRegion exposeRegion;
 #if (MOZ_WIDGET_GTK == 2)
     if (!ExtractExposeRegion(exposeRegion, aEvent)) {
@@ -3055,11 +3076,20 @@ nsWindow::GetEventTimeStamp(guint32 aEventTime)
         // In this case too, just return the current timestamp.
         return TimeStamp::Now();
     }
-    CurrentX11TimeGetter* getCurrentTime = GetCurrentTimeGetter();
-    MOZ_ASSERT(getCurrentTime,
-               "Null current time getter despite having a window");
-    return TimeConverter().GetTimeStampFromSystemTime(aEventTime,
-                                                      *getCurrentTime);
+    if (!mIsX11Display) {
+        // Wayland uses SYSTEM_TIME_MONOTONIC.
+        // Our posix implemententaion of TimeStamp::Now uses SYSTEM_TIME_MONOTONIC
+        //  too. Due to same implementation, we can use this via FromSystemTime.
+        int64_t tick =
+           BaseTimeDurationPlatformUtils::TicksFromMilliseconds(aEventTime);
+        return TimeStamp::FromSystemTime(tick);
+    } else {
+        CurrentX11TimeGetter* getCurrentTime = GetCurrentTimeGetter();
+        MOZ_ASSERT(getCurrentTime,
+                   "Null current time getter despite having a window");
+        return TimeConverter().GetTimeStampFromSystemTime(aEventTime,
+                                                          *getCurrentTime);
+    }
 }
 
 mozilla::CurrentX11TimeGetter*
@@ -3773,7 +3803,13 @@ nsWindow::Create(nsIWidget* aParent,
         // We can't draw directly to top-level window when client side
         // decorations are enabled. We use container with GdkWindow instead.
         GtkStyleContext* style = gtk_widget_get_style_context(mShell);
+
+        // Always draw to mozcontainer on Wayland
         shellHasCSD = gtk_style_context_has_class(style, "csd");
+        // We use mContainer to draw on Wayland
+        if (!mIsX11Display) {
+            shellHasCSD = true;
+        }
 #endif
         if (!shellHasCSD) {
             // Use mShell's window for drawing and events.
@@ -3781,13 +3817,14 @@ nsWindow::Create(nsIWidget* aParent,
             // Prevent GtkWindow from painting a background to flicker.
             gtk_widget_set_app_paintable(mShell, TRUE);
         }
+
         // Set up event widget
         eventWidget = shellHasCSD ? container : mShell;
         gtk_widget_add_events(eventWidget, kEvents);
 
         gtk_container_add(GTK_CONTAINER(mShell), container);
         gtk_widget_realize(container);
-
+        
         // make sure this is the focus widget in the container
         gtk_widget_show(container);
         gtk_widget_grab_focus(container);
@@ -4021,8 +4058,14 @@ nsWindow::Create(nsIWidget* aParent,
 
       mSurfaceProvider.Initialize(mXDisplay, mXWindow, mXVisual, mXDepth);
     }
+#ifdef MOZ_WAYLAND
+    else {
+      mWaylandDisplay = gdk_wayland_display_get_wl_display(gdk_display_get_default());
+      mWaylandSurface = moz_container_get_wl_surface(MOZ_CONTAINER(mContainer));
+      mSurfaceProvider.Initialize(this, mWaylandDisplay, mWaylandSurface);
+    }
+#endif
 #endif
-
     return NS_OK;
 }
 
@@ -4203,7 +4246,6 @@ nsWindow::NativeShow(bool aAction)
             if (mWindowType != eWindowType_invisible) {
                 SetUserTimeAndStartupIDForActivatedWindow(mShell);
             }
-
             gtk_widget_show(mShell);
         }
         else if (mContainer) {
@@ -4704,7 +4746,12 @@ nsWindow::GrabPointer(guint32 aTime)
 
     if (!mGdkWindow)
         return;
-
+/*
+    GdkSeat *gdkSeat = gdk_display_get_default_seat(gdk_display_get_default());
+    gint retval;
+    retval = gdk_seat_grab(gdkSeat, mGdkWindow, GDK_SEAT_CAPABILITY_ALL_POINTING, TRUE,
+                           nullptr, nullptr, nullptr, nullptr);
+*/
     gint retval;
     retval = gdk_pointer_grab(mGdkWindow, TRUE,
                               (GdkEventMask)(GDK_BUTTON_PRESS_MASK |
@@ -4736,6 +4783,10 @@ nsWindow::ReleaseGrabs(void)
     LOG(("ReleaseGrabs\n"));
 
     mRetryPointerGrab = false;
+/*
+    GdkSeat *gdkSeat = gdk_display_get_default_seat(gdk_display_get_default());
+    gdk_seat_ungrab(gdkSeat);
+*/
     gdk_pointer_ungrab(GDK_CURRENT_TIME);
 }
 
@@ -6687,8 +6738,7 @@ nsWindow::BeginResizeDrag(WidgetGUIEvent* aEvent,
             window_edge = GDK_WINDOW_EDGE_NORTH_WEST;
         } else if (aHorizontal == 0) {
             window_edge = GDK_WINDOW_EDGE_NORTH;
-        } else {
-            window_edge = GDK_WINDOW_EDGE_NORTH_EAST;
+        } else {            window_edge = GDK_WINDOW_EDGE_NORTH_EAST;
         }
     } else if (aVertical == 0) {
         if (aHorizontal < 0) {
@@ -7027,10 +7077,20 @@ nsWindow::RoundsWidgetCoordinatesTo()
 
 void nsWindow::GetCompositorWidgetInitData(mozilla::widget::CompositorWidgetInitData* aInitData)
 {
-  #ifdef MOZ_X11
-  *aInitData = mozilla::widget::CompositorWidgetInitData(
+#ifdef MOZ_X11
+#ifdef MOZ_WAYLAND
+  if (!mIsX11Display) {
+    *aInitData = mozilla::widget::CompositorWidgetInitData(
+                                  (uintptr_t)mWaylandSurface,
+                                  nsCString(nullptr),
+                                  GetClientSize());
+  } else
+#endif
+  {
+    *aInitData = mozilla::widget::CompositorWidgetInitData(
                                   mXWindow,
                                   nsCString(XDisplayString(mXDisplay)),
                                   GetClientSize());
-  #endif
+  }
+#endif
 }
diff --git a/widget/gtk/nsWindow.h b/widget/gtk/nsWindow.h
index 49a8d4b..e571bed 100644
--- a/widget/gtk/nsWindow.h
+++ b/widget/gtk/nsWindow.h
@@ -23,6 +23,9 @@
 #ifdef MOZ_X11
 #include <gdk/gdkx.h>
 #endif /* MOZ_X11 */
+#ifdef MOZ_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
 
 #include "mozilla/widget/WindowSurface.h"
 #include "mozilla/widget/WindowSurfaceProvider.h"
@@ -346,9 +349,13 @@ public:
                                                 nsIObserver* aObserver) override;
 #endif
 
+    bool     IsX11Display() { return mIsX11Display; }
 #ifdef MOZ_X11
     Display* XDisplay() { return mXDisplay; }
 #endif
+#ifdef MOZ_WAYLAND
+    wl_display* WaylandDisplay() { return mWaylandDisplay; }
+#endif
     virtual void GetCompositorWidgetInitData(mozilla::widget::CompositorWidgetInitData* aInitData) override;
 
     // HiDPI scale conversion
@@ -462,9 +469,12 @@ private:
     Window              mXWindow;
     Visual*             mXVisual;
     int                 mXDepth;
+#ifdef MOZ_WAYLAND
+    wl_display*         mWaylandDisplay;
+    wl_surface*         mWaylandSurface;
+#endif
     mozilla::widget::WindowSurfaceProvider mSurfaceProvider;
 #endif
-
     // Upper bound on pending ConfigureNotify events to be dispatched to the
     // window. See bug 1225044.
     unsigned int mPendingConfigures;
diff --git a/widget/nsBaseWidget.cpp b/widget/nsBaseWidget.cpp
index b820fed..ba7fb91 100644
--- a/widget/nsBaseWidget.cpp
+++ b/widget/nsBaseWidget.cpp
@@ -1407,6 +1407,7 @@ void nsBaseWidget::NotifyRemoteCompositorSessionLost(CompositorSession* aSession
 bool nsBaseWidget::ShouldUseOffMainThreadCompositing()
 {
   return gfxPlatform::UsesOffMainThreadCompositing();
+  //return false;
 }
 
 LayerManager* nsBaseWidget::GetLayerManager(PLayerTransactionChild* aShadowManager,
